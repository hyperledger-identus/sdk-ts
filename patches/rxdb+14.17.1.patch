diff --git a/node_modules/rxdb/dist/es/plugins/encryption-crypto-js/index.js b/node_modules/rxdb/dist/es/plugins/encryption-crypto-js/index.js
deleted file mode 100644
index 212968e..0000000
--- a/node_modules/rxdb/dist/es/plugins/encryption-crypto-js/index.js
+++ /dev/null
@@ -1,133 +0,0 @@
-/**
- * this plugin adds the encryption-capabilities to rxdb
- * It's using crypto-js/aes for password-encryption
- * @link https://github.com/brix/crypto-js
- */
-import AES from 'crypto-js/aes';
-import * as cryptoEnc from 'crypto-js/enc-utf8';
-import { wrapRxStorageInstance } from '../../plugin-helpers';
-import { newRxError, newRxTypeError } from '../../rx-error';
-import { hasEncryption } from '../../rx-storage-helper';
-import { b64DecodeUnicode, b64EncodeUnicode, clone, ensureNotFalsy, flatClone, getProperty, setProperty } from '../../plugins/utils';
-export var MINIMUM_PASSWORD_LENGTH = 8;
-export function encryptString(value, password) {
-  var encrypted = AES.encrypt(value, password);
-  return encrypted.toString();
-}
-export function decryptString(cipherText, password) {
-  /**
-   * Trying to decrypt non-strings
-   * will cause no errors and will be hard to debug.
-   * So instead we do this check here.
-   */
-  if (typeof cipherText !== 'string') {
-    throw newRxError('SNH', {
-      args: {
-        cipherText
-      }
-    });
-  }
-  var decrypted = AES.decrypt(cipherText, password);
-  var ret = decrypted.toString(cryptoEnc);
-  return ret;
-}
-export function wrappedKeyEncryptionCryptoJsStorage(args) {
-  return Object.assign({}, args.storage, {
-    async createStorageInstance(params) {
-      if (typeof params.password !== 'undefined') {
-        validatePassword(params.password);
-      }
-      if (!hasEncryption(params.schema)) {
-        var retInstance = await args.storage.createStorageInstance(params);
-        return retInstance;
-      }
-      if (!params.password) {
-        throw newRxError('EN3', {
-          database: params.databaseName,
-          collection: params.collectionName,
-          schema: params.schema
-        });
-      }
-      var password = params.password;
-      var schemaWithoutEncrypted = clone(params.schema);
-      delete schemaWithoutEncrypted.encrypted;
-      if (schemaWithoutEncrypted.attachments) {
-        schemaWithoutEncrypted.attachments.encrypted = false;
-      }
-      var instance = await args.storage.createStorageInstance(Object.assign({}, params, {
-        schema: schemaWithoutEncrypted
-      }));
-      function modifyToStorage(docData) {
-        docData = cloneWithoutAttachments(docData);
-        ensureNotFalsy(params.schema.encrypted).forEach(path => {
-          var value = getProperty(docData, path);
-          if (typeof value === 'undefined') {
-            return;
-          }
-          var stringValue = JSON.stringify(value);
-          var encrypted = encryptString(stringValue, password);
-          setProperty(docData, path, encrypted);
-        });
-
-        // handle attachments
-        if (params.schema.attachments && params.schema.attachments.encrypted) {
-          var newAttachments = {};
-          Object.entries(docData._attachments).forEach(([id, attachment]) => {
-            var useAttachment = flatClone(attachment);
-            if (useAttachment.data) {
-              var dataString = useAttachment.data;
-              useAttachment.data = b64EncodeUnicode(encryptString(dataString, password));
-            }
-            newAttachments[id] = useAttachment;
-          });
-          docData._attachments = newAttachments;
-        }
-        return docData;
-      }
-      function modifyFromStorage(docData) {
-        docData = cloneWithoutAttachments(docData);
-        ensureNotFalsy(params.schema.encrypted).forEach(path => {
-          var value = getProperty(docData, path);
-          if (typeof value === 'undefined') {
-            return;
-          }
-          var decrypted = decryptString(value, password);
-          var decryptedParsed = JSON.parse(decrypted);
-          setProperty(docData, path, decryptedParsed);
-        });
-        return docData;
-      }
-      function modifyAttachmentFromStorage(attachmentData) {
-        if (params.schema.attachments && params.schema.attachments.encrypted) {
-          var decrypted = decryptString(b64DecodeUnicode(attachmentData), password);
-          return decrypted;
-        } else {
-          return attachmentData;
-        }
-      }
-      return wrapRxStorageInstance(instance, modifyToStorage, modifyFromStorage, modifyAttachmentFromStorage);
-    }
-  });
-}
-function cloneWithoutAttachments(data) {
-  var attachments = data._attachments;
-  data = flatClone(data);
-  delete data._attachments;
-  data = clone(data);
-  data._attachments = attachments;
-  return data;
-}
-function validatePassword(password) {
-  if (typeof password !== 'string') {
-    throw newRxTypeError('EN1', {
-      password
-    });
-  }
-  if (password.length < MINIMUM_PASSWORD_LENGTH) {
-    throw newRxError('EN2', {
-      minPassLength: MINIMUM_PASSWORD_LENGTH,
-      password
-    });
-  }
-}
-//# sourceMappingURL=index.js.map
\ No newline at end of file
diff --git a/node_modules/rxdb/dist/es/plugins/encryption-crypto-js/index.js.map b/node_modules/rxdb/dist/es/plugins/encryption-crypto-js/index.js.map
deleted file mode 100644
index cb51958..0000000
--- a/node_modules/rxdb/dist/es/plugins/encryption-crypto-js/index.js.map
+++ /dev/null
@@ -1 +0,0 @@
-{"version":3,"file":"index.js","names":["AES","cryptoEnc","wrapRxStorageInstance","newRxError","newRxTypeError","hasEncryption","b64DecodeUnicode","b64EncodeUnicode","clone","ensureNotFalsy","flatClone","getProperty","setProperty","MINIMUM_PASSWORD_LENGTH","encryptString","value","password","encrypted","encrypt","toString","decryptString","cipherText","args","decrypted","decrypt","ret","wrappedKeyEncryptionCryptoJsStorage","Object","assign","storage","createStorageInstance","params","validatePassword","schema","retInstance","database","databaseName","collection","collectionName","schemaWithoutEncrypted","attachments","instance","modifyToStorage","docData","cloneWithoutAttachments","forEach","path","stringValue","JSON","stringify","newAttachments","entries","_attachments","id","attachment","useAttachment","data","dataString","modifyFromStorage","decryptedParsed","parse","modifyAttachmentFromStorage","attachmentData","length","minPassLength"],"sources":["../../../../src/plugins/encryption-crypto-js/index.ts"],"sourcesContent":["/**\n * this plugin adds the encryption-capabilities to rxdb\n * It's using crypto-js/aes for password-encryption\n * @link https://github.com/brix/crypto-js\n */\nimport AES from 'crypto-js/aes';\nimport * as cryptoEnc from 'crypto-js/enc-utf8';\nimport { wrapRxStorageInstance } from '../../plugin-helpers';\nimport { newRxError, newRxTypeError } from '../../rx-error';\nimport { hasEncryption } from '../../rx-storage-helper';\nimport type {\n    InternalStoreDocType,\n    RxAttachmentWriteData,\n    RxDocumentData,\n    RxDocumentWriteData,\n    RxJsonSchema,\n    RxStorage,\n    RxStorageInstanceCreationParams\n} from '../../types';\nimport {\n    b64DecodeUnicode,\n    b64EncodeUnicode,\n    clone,\n    ensureNotFalsy,\n    flatClone,\n    getProperty,\n    setProperty\n} from '../../plugins/utils';\n\nexport const MINIMUM_PASSWORD_LENGTH: 8 = 8;\n\n\nexport function encryptString(value: string, password: string): string {\n    const encrypted = AES.encrypt(value, password);\n    return encrypted.toString();\n}\n\nexport function decryptString(cipherText: string, password: any): string {\n    /**\n     * Trying to decrypt non-strings\n     * will cause no errors and will be hard to debug.\n     * So instead we do this check here.\n     */\n    if (typeof cipherText !== 'string') {\n        throw newRxError('SNH', {\n            args: {\n                cipherText\n            }\n        });\n    }\n\n    const decrypted = AES.decrypt(cipherText, password);\n    const ret = decrypted.toString(cryptoEnc);\n    return ret;\n}\n\nexport type InternalStorePasswordDocType = InternalStoreDocType<{\n    hash: string;\n}>;\n\nexport function wrappedKeyEncryptionCryptoJsStorage<Internals, InstanceCreationOptions>(\n    args: {\n        storage: RxStorage<Internals, InstanceCreationOptions>;\n    }\n): RxStorage<Internals, InstanceCreationOptions> {\n    return Object.assign(\n        {},\n        args.storage,\n        {\n            async createStorageInstance<RxDocType>(\n                params: RxStorageInstanceCreationParams<RxDocType, any>\n            ) {\n                if (typeof params.password !== 'undefined') {\n                    validatePassword(params.password as any);\n                }\n\n                if (!hasEncryption(params.schema)) {\n                    const retInstance = await args.storage.createStorageInstance(params);\n                    return retInstance;\n                }\n\n                if (!params.password) {\n                    throw newRxError('EN3', {\n                        database: params.databaseName,\n                        collection: params.collectionName,\n                        schema: params.schema\n                    });\n                }\n                const password = params.password;\n\n                const schemaWithoutEncrypted: RxJsonSchema<RxDocumentData<RxDocType>> = clone(params.schema);\n                delete schemaWithoutEncrypted.encrypted;\n                if (schemaWithoutEncrypted.attachments) {\n                    schemaWithoutEncrypted.attachments.encrypted = false;\n                }\n\n                const instance = await args.storage.createStorageInstance(\n                    Object.assign(\n                        {},\n                        params,\n                        {\n                            schema: schemaWithoutEncrypted\n                        }\n                    )\n                );\n\n                function modifyToStorage(docData: RxDocumentWriteData<RxDocType>) {\n                    docData = cloneWithoutAttachments(docData);\n                    ensureNotFalsy(params.schema.encrypted)\n                        .forEach(path => {\n                            const value = getProperty(docData, path);\n                            if (typeof value === 'undefined') {\n                                return;\n                            }\n\n                            const stringValue = JSON.stringify(value);\n                            const encrypted = encryptString(stringValue, password);\n                            setProperty(docData, path, encrypted);\n                        });\n\n                    // handle attachments\n                    if (\n                        params.schema.attachments &&\n                        params.schema.attachments.encrypted\n                    ) {\n                        const newAttachments: typeof docData._attachments = {};\n                        Object.entries(docData._attachments).forEach(([id, attachment]) => {\n                            const useAttachment: RxAttachmentWriteData = flatClone(attachment) as any;\n                            if (useAttachment.data) {\n                                const dataString = useAttachment.data;\n                                useAttachment.data = b64EncodeUnicode(encryptString(dataString, password));\n                            }\n                            newAttachments[id] = useAttachment;\n                        });\n                        docData._attachments = newAttachments;\n                    }\n                    return docData;\n                }\n                function modifyFromStorage(docData: RxDocumentData<any>): Promise<RxDocumentData<RxDocType>> {\n                    docData = cloneWithoutAttachments(docData);\n                    ensureNotFalsy(params.schema.encrypted)\n                        .forEach(path => {\n                            const value = getProperty(docData, path);\n                            if (typeof value === 'undefined') {\n                                return;\n                            }\n                            const decrypted = decryptString(value, password);\n                            const decryptedParsed = JSON.parse(decrypted);\n                            setProperty(docData, path, decryptedParsed);\n                        });\n                    return docData;\n                }\n\n                function modifyAttachmentFromStorage(attachmentData: string): string {\n                    if (\n                        params.schema.attachments &&\n                        params.schema.attachments.encrypted\n                    ) {\n                        const decrypted = decryptString(b64DecodeUnicode(attachmentData), password);\n                        return decrypted;\n                    } else {\n                        return attachmentData;\n                    }\n                }\n\n                return wrapRxStorageInstance(\n                    instance,\n                    modifyToStorage,\n                    modifyFromStorage,\n                    modifyAttachmentFromStorage\n                );\n            }\n        }\n    );\n}\n\n\n\n\n\nfunction cloneWithoutAttachments<T>(data: RxDocumentWriteData<T>): RxDocumentData<T> {\n    const attachments = data._attachments;\n    data = flatClone(data);\n    delete (data as any)._attachments;\n    data = clone(data);\n    data._attachments = attachments;\n    return data as any;\n}\n\nfunction validatePassword(password: string) {\n    if (typeof password !== 'string') {\n        throw newRxTypeError('EN1', {\n            password\n        });\n    }\n    if (password.length < MINIMUM_PASSWORD_LENGTH) {\n        throw newRxError('EN2', {\n            minPassLength: MINIMUM_PASSWORD_LENGTH,\n            password\n        });\n    }\n}\n"],"mappings":"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"}
\ No newline at end of file
diff --git a/node_modules/rxdb/dist/es/plugins/replication-firestore/firestore-helper.js b/node_modules/rxdb/dist/es/plugins/replication-firestore/firestore-helper.js
deleted file mode 100644
index dd07143..0000000
--- a/node_modules/rxdb/dist/es/plugins/replication-firestore/firestore-helper.js
+++ /dev/null
@@ -1,47 +0,0 @@
-import { Timestamp } from 'firebase/firestore';
-import { flatClone, now } from '../../plugins/utils';
-export var FIRESTORE_REPLICATION_PLUGIN_IDENTITY_PREFIX = 'firestore';
-export function getFirestoreSortFieldValue(docData, primaryKey) {
-  var timeString = now() + '';
-  return 'rxdb-' + timeString.padStart(15, '0') + '-' + docData[primaryKey];
-}
-export function stripServerTimestampField(serverTimestampField, docData) {
-  var data = flatClone(docData);
-  delete data[serverTimestampField];
-  return data;
-}
-export function serverTimestampToIsoString(serverTimestampField, docData) {
-  var timestamp = docData[serverTimestampField];
-  var date = timestamp.toDate();
-  return date.toISOString();
-}
-export function isoStringToServerTimestamp(isoString) {
-  var date = new Date(isoString);
-  return Timestamp.fromDate(date);
-}
-export function firestoreRowToDocData(serverTimestampField, primaryPath, row) {
-  var docData = stripServerTimestampField(serverTimestampField, row.data());
-  docData[primaryPath] = row.id;
-  return docData;
-}
-export function stripPrimaryKey(primaryPath, docData) {
-  docData = flatClone(docData);
-  delete docData[primaryPath];
-  return docData;
-}
-
-// https://stackoverflow.com/questions/61354866/is-there-a-workaround-for-the-firebase-query-in-limit-to-10
-export function getContentByIds(ids, getQuery) {
-  var batches = [];
-  while (ids.length) {
-    // firestore limits batches to 10
-    var batch = ids.splice(0, 10);
-
-    // add the batch request to to a queue
-    batches.push(getQuery(batch));
-  }
-
-  // after all of the data is fetched, return it
-  return Promise.all(batches).then(content => content.map(i => i.docs).flat());
-}
-//# sourceMappingURL=firestore-helper.js.map
\ No newline at end of file
diff --git a/node_modules/rxdb/dist/es/plugins/replication-firestore/firestore-helper.js.map b/node_modules/rxdb/dist/es/plugins/replication-firestore/firestore-helper.js.map
deleted file mode 100644
index 8a9f61b..0000000
--- a/node_modules/rxdb/dist/es/plugins/replication-firestore/firestore-helper.js.map
+++ /dev/null
@@ -1 +0,0 @@
-{"version":3,"file":"firestore-helper.js","names":["Timestamp","flatClone","now","FIRESTORE_REPLICATION_PLUGIN_IDENTITY_PREFIX","getFirestoreSortFieldValue","docData","primaryKey","timeString","padStart","stripServerTimestampField","serverTimestampField","data","serverTimestampToIsoString","timestamp","date","toDate","toISOString","isoStringToServerTimestamp","isoString","Date","fromDate","firestoreRowToDocData","primaryPath","row","id","stripPrimaryKey","getContentByIds","ids","getQuery","batches","length","batch","splice","push","Promise","all","then","content","map","i","docs","flat"],"sources":["../../../../src/plugins/replication-firestore/firestore-helper.ts"],"sourcesContent":["import {\n    QueryDocumentSnapshot,\n    Timestamp\n} from 'firebase/firestore';\nimport type {\n    WithDeleted\n} from '../../types';\nimport { flatClone, now } from '../../plugins/utils';\nimport type { GetQuery } from './firestore-types';\n\nexport const FIRESTORE_REPLICATION_PLUGIN_IDENTITY_PREFIX = 'firestore';\n\n\nexport function getFirestoreSortFieldValue(docData: any, primaryKey: string): string {\n    const timeString = now() + '';\n    return 'rxdb-' + timeString.padStart(15, '0') + '-' + docData[primaryKey];\n}\n\nexport function stripServerTimestampField<RxDocType>(\n    serverTimestampField: string,\n    docData: RxDocType\n): WithDeleted<RxDocType> {\n    const data = flatClone(docData);\n    delete (data as any)[serverTimestampField];\n    return data as any;\n}\n\n\nexport function serverTimestampToIsoString(serverTimestampField: string, docData: any): string {\n    const timestamp = (docData as any)[serverTimestampField];\n    const date: Date = timestamp.toDate();\n    return date.toISOString();\n}\n\nexport function isoStringToServerTimestamp(isoString: string): Timestamp {\n    const date = new Date(isoString);\n    return Timestamp.fromDate(date);\n}\n\nexport function firestoreRowToDocData<RxDocType>(\n    serverTimestampField: string,\n    primaryPath: string,\n    row: QueryDocumentSnapshot<RxDocType>\n): WithDeleted<RxDocType> {\n    const docData = stripServerTimestampField(\n        serverTimestampField,\n        row.data()\n    );\n    (docData as any)[primaryPath] = row.id;\n    return docData;\n}\n\nexport function stripPrimaryKey(\n    primaryPath: string,\n    docData: any\n): any {\n    docData = flatClone(docData);\n    delete (docData as any)[primaryPath];\n    return docData;\n}\n\n// https://stackoverflow.com/questions/61354866/is-there-a-workaround-for-the-firebase-query-in-limit-to-10\nexport function getContentByIds<RxDocType>(ids: string[], getQuery: GetQuery<RxDocType>): Promise<QueryDocumentSnapshot<RxDocType>[]> {\n    const batches = [];\n\n    while (ids.length) {\n        // firestore limits batches to 10\n        const batch = ids.splice(0, 10);\n\n        // add the batch request to to a queue\n        batches.push(getQuery(batch));\n    }\n\n    // after all of the data is fetched, return it\n    return Promise.all(batches).then((content) => content.map(i => i.docs).flat());\n}\n"],"mappings":"AAAA,SAEIA,SAAS,QACN,oBAAoB;AAI3B,SAASC,SAAS,EAAEC,GAAG,QAAQ,qBAAqB;AAGpD,OAAO,IAAMC,4CAA4C,GAAG,WAAW;AAGvE,OAAO,SAASC,0BAA0BA,CAACC,OAAY,EAAEC,UAAkB,EAAU;EACjF,IAAMC,UAAU,GAAGL,GAAG,CAAC,CAAC,GAAG,EAAE;EAC7B,OAAO,OAAO,GAAGK,UAAU,CAACC,QAAQ,CAAC,EAAE,EAAE,GAAG,CAAC,GAAG,GAAG,GAAGH,OAAO,CAACC,UAAU,CAAC;AAC7E;AAEA,OAAO,SAASG,yBAAyBA,CACrCC,oBAA4B,EAC5BL,OAAkB,EACI;EACtB,IAAMM,IAAI,GAAGV,SAAS,CAACI,OAAO,CAAC;EAC/B,OAAQM,IAAI,CAASD,oBAAoB,CAAC;EAC1C,OAAOC,IAAI;AACf;AAGA,OAAO,SAASC,0BAA0BA,CAACF,oBAA4B,EAAEL,OAAY,EAAU;EAC3F,IAAMQ,SAAS,GAAIR,OAAO,CAASK,oBAAoB,CAAC;EACxD,IAAMI,IAAU,GAAGD,SAAS,CAACE,MAAM,CAAC,CAAC;EACrC,OAAOD,IAAI,CAACE,WAAW,CAAC,CAAC;AAC7B;AAEA,OAAO,SAASC,0BAA0BA,CAACC,SAAiB,EAAa;EACrE,IAAMJ,IAAI,GAAG,IAAIK,IAAI,CAACD,SAAS,CAAC;EAChC,OAAOlB,SAAS,CAACoB,QAAQ,CAACN,IAAI,CAAC;AACnC;AAEA,OAAO,SAASO,qBAAqBA,CACjCX,oBAA4B,EAC5BY,WAAmB,EACnBC,GAAqC,EACf;EACtB,IAAMlB,OAAO,GAAGI,yBAAyB,CACrCC,oBAAoB,EACpBa,GAAG,CAACZ,IAAI,CAAC,CACb,CAAC;EACAN,OAAO,CAASiB,WAAW,CAAC,GAAGC,GAAG,CAACC,EAAE;EACtC,OAAOnB,OAAO;AAClB;AAEA,OAAO,SAASoB,eAAeA,CAC3BH,WAAmB,EACnBjB,OAAY,EACT;EACHA,OAAO,GAAGJ,SAAS,CAACI,OAAO,CAAC;EAC5B,OAAQA,OAAO,CAASiB,WAAW,CAAC;EACpC,OAAOjB,OAAO;AAClB;;AAEA;AACA,OAAO,SAASqB,eAAeA,CAAYC,GAAa,EAAEC,QAA6B,EAA+C;EAClI,IAAMC,OAAO,GAAG,EAAE;EAElB,OAAOF,GAAG,CAACG,MAAM,EAAE;IACf;IACA,IAAMC,KAAK,GAAGJ,GAAG,CAACK,MAAM,CAAC,CAAC,EAAE,EAAE,CAAC;;IAE/B;IACAH,OAAO,CAACI,IAAI,CAACL,QAAQ,CAACG,KAAK,CAAC,CAAC;EACjC;;EAEA;EACA,OAAOG,OAAO,CAACC,GAAG,CAACN,OAAO,CAAC,CAACO,IAAI,CAAEC,OAAO,IAAKA,OAAO,CAACC,GAAG,CAACC,CAAC,IAAIA,CAAC,CAACC,IAAI,CAAC,CAACC,IAAI,CAAC,CAAC,CAAC;AAClF"}
\ No newline at end of file
diff --git a/node_modules/rxdb/dist/es/plugins/replication-firestore/firestore-types.js b/node_modules/rxdb/dist/es/plugins/replication-firestore/firestore-types.js
deleted file mode 100644
index 84d820d..0000000
--- a/node_modules/rxdb/dist/es/plugins/replication-firestore/firestore-types.js
+++ /dev/null
@@ -1,3 +0,0 @@
-export {};
-export {};
-//# sourceMappingURL=firestore-types.js.map
\ No newline at end of file
diff --git a/node_modules/rxdb/dist/es/plugins/replication-firestore/firestore-types.js.map b/node_modules/rxdb/dist/es/plugins/replication-firestore/firestore-types.js.map
deleted file mode 100644
index 1bd05e8..0000000
--- a/node_modules/rxdb/dist/es/plugins/replication-firestore/firestore-types.js.map
+++ /dev/null
@@ -1 +0,0 @@
-{"version":3,"file":"firestore-types.js","names":[],"sources":["../../../../src/plugins/replication-firestore/firestore-types.ts"],"sourcesContent":["import type {\n    MaybePromise,\n    ReplicationOptions,\n    ReplicationPullOptions,\n    ReplicationPushOptions,\n    WithDeleted\n} from '../../types';\n\nimport type {\n    CollectionReference,\n    Firestore,\n    QueryFieldFilterConstraint,\n    QuerySnapshot\n} from 'firebase/firestore';\n\nexport type FirestoreCheckpointType = {\n    id: string;\n    /**\n     * Firestore internally sets the time to an object like\n     * {\n     *       \"seconds\": 1669807105,\n     *       \"nanoseconds\": 476000000\n     * }\n     * But to be able to query that, we have to use a date string\n     * like '2022-11-30T11:18:25.141Z'\n     * so we store that string instead.\n     */\n    serverTimestamp: string;\n};\nexport type FirestoreCollection<RxDocType> = CollectionReference<RxDocType>;\n\nexport type FirestoreOptions<RxDocType> = {\n    projectId: string;\n    collection: FirestoreCollection<RxDocType>;\n    database: Firestore;\n};\n\nexport type FirestoreSyncPullOptions<RxDocType> =\n    Omit<ReplicationPullOptions<RxDocType, FirestoreCheckpointType>, 'handler' | 'stream$'>\n    & {\n        filter?: QueryFieldFilterConstraint | QueryFieldFilterConstraint[];\n    };\n\nexport type FirestoreSyncPushOptions<RxDocType> = Omit<ReplicationPushOptions<RxDocType>, 'handler'>\n    & {\n        filter?(item: WithDeleted<RxDocType>): MaybePromise<boolean>;\n    };\n\nexport type SyncOptionsFirestore<RxDocType> = Omit<\n    ReplicationOptions<RxDocType, any>,\n    'pull' | 'push' | 'replicationIdentifier'\n> & {\n    firestore: FirestoreOptions<RxDocType>;\n    /**\n     * In firestore it is not possible to read out\n     * the internally used write timestamp.\n     * Even if we could read it out, it is not indexed which\n     * is required for fetch 'changes-since-x'.\n     * So instead we have to rely on a custom user defined field\n     * that contains the server time which is set by firestore via serverTimestamp()\n     * IMPORTANT: The serverTimestampField MUST NOT be part of the collections RxJsonSchema!\n     * [default='serverTimestamp']\n     * @link https://groups.google.com/g/firebase-talk/c/tAmPzPei-mE\n     */\n    serverTimestampField?: string;\n    pull?: FirestoreSyncPullOptions<RxDocType>;\n    push?: FirestoreSyncPushOptions<RxDocType>;\n};\n\nexport type GetQuery<RxDocType> = (ids: string[]) => Promise<QuerySnapshot<RxDocType>>;\n"],"mappings":""}
\ No newline at end of file
diff --git a/node_modules/rxdb/dist/es/plugins/replication-firestore/index.js b/node_modules/rxdb/dist/es/plugins/replication-firestore/index.js
deleted file mode 100644
index 3b20cff..0000000
--- a/node_modules/rxdb/dist/es/plugins/replication-firestore/index.js
+++ /dev/null
@@ -1,228 +0,0 @@
-import _inheritsLoose from "@babel/runtime/helpers/inheritsLoose";
-import { appendToArray, asyncFilter, ensureNotFalsy, errorToPlainJson, flatClone, lastOfArray, toArray } from '../../plugins/utils';
-import { doc, query, where, orderBy, limit, getDocs, onSnapshot, runTransaction, writeBatch, serverTimestamp, waitForPendingWrites, documentId } from 'firebase/firestore';
-import { RxDBLeaderElectionPlugin } from '../leader-election';
-import { RxReplicationState, startReplicationOnLeaderShip } from '../replication';
-import { addRxPlugin, getSchemaByObjectPath, newRxError } from '../../';
-import { Subject } from 'rxjs';
-import { firestoreRowToDocData, FIRESTORE_REPLICATION_PLUGIN_IDENTITY_PREFIX, getContentByIds, isoStringToServerTimestamp, serverTimestampToIsoString, stripPrimaryKey, stripServerTimestampField } from './firestore-helper';
-export * from './firestore-helper';
-export * from './firestore-types';
-export var RxFirestoreReplicationState = /*#__PURE__*/function (_RxReplicationState) {
-  _inheritsLoose(RxFirestoreReplicationState, _RxReplicationState);
-  function RxFirestoreReplicationState(firestore, replicationIdentifierHash, collection, pull, push, live = true, retryTime = 1000 * 5, autoStart = true) {
-    var _this;
-    _this = _RxReplicationState.call(this, replicationIdentifierHash, collection, '_deleted', pull, push, live, retryTime, autoStart) || this;
-    _this.firestore = firestore;
-    _this.replicationIdentifierHash = replicationIdentifierHash;
-    _this.collection = collection;
-    _this.pull = pull;
-    _this.push = push;
-    _this.live = live;
-    _this.retryTime = retryTime;
-    _this.autoStart = autoStart;
-    return _this;
-  }
-  return RxFirestoreReplicationState;
-}(RxReplicationState);
-export function replicateFirestore(options) {
-  var collection = options.collection;
-  addRxPlugin(RxDBLeaderElectionPlugin);
-  var pullStream$ = new Subject();
-  var replicationPrimitivesPull;
-  options.live = typeof options.live === 'undefined' ? true : options.live;
-  options.waitForLeadership = typeof options.waitForLeadership === 'undefined' ? true : options.waitForLeadership;
-  var serverTimestampField = typeof options.serverTimestampField === 'undefined' ? 'serverTimestamp' : options.serverTimestampField;
-  options.serverTimestampField = serverTimestampField;
-  var primaryPath = collection.schema.primaryPath;
-
-  /**
-   * The serverTimestampField MUST NOT be part of the collections RxJsonSchema.
-   */
-  var schemaPart = getSchemaByObjectPath(collection.schema.jsonSchema, serverTimestampField);
-  if (schemaPart ||
-  // also must not be nested.
-  serverTimestampField.includes('.')) {
-    throw newRxError('RC6', {
-      field: serverTimestampField,
-      schema: collection.schema.jsonSchema
-    });
-  }
-  var pullFilters = options.pull?.filter !== undefined ? toArray(options.pull.filter) : [];
-  var pullQuery = query(options.firestore.collection, ...pullFilters);
-  if (options.pull) {
-    replicationPrimitivesPull = {
-      async handler(lastPulledCheckpoint, batchSize) {
-        var newerQuery;
-        var sameTimeQuery;
-        if (lastPulledCheckpoint) {
-          var lastServerTimestamp = isoStringToServerTimestamp(lastPulledCheckpoint.serverTimestamp);
-          newerQuery = query(pullQuery, where(serverTimestampField, '>', lastServerTimestamp), orderBy(serverTimestampField, 'asc'), limit(batchSize));
-          sameTimeQuery = query(pullQuery, where(serverTimestampField, '==', lastServerTimestamp), where(primaryPath, '>', lastPulledCheckpoint.id), orderBy(primaryPath, 'asc'), limit(batchSize));
-        } else {
-          newerQuery = query(pullQuery, orderBy(serverTimestampField, 'asc'), limit(batchSize));
-        }
-        var mustsReRun = true;
-        var useDocs = [];
-        while (mustsReRun) {
-          /**
-           * Local writes that have not been persisted to the server
-           * are in pending state and do not have a correct serverTimestamp set.
-           * We have to ensure we only use document states that are in sync with the server.
-           * @link https://medium.com/firebase-developers/the-secrets-of-firestore-fieldvalue-servertimestamp-revealed-29dd7a38a82b
-           */
-          await waitForPendingWrites(options.firestore.database);
-          await runTransaction(options.firestore.database, async _tx => {
-            useDocs = [];
-            var [newerQueryResult, sameTimeQueryResult] = await Promise.all([getDocs(newerQuery), sameTimeQuery ? getDocs(sameTimeQuery) : undefined]);
-            if (newerQueryResult.metadata.hasPendingWrites || sameTimeQuery && ensureNotFalsy(sameTimeQueryResult).metadata.hasPendingWrites) {
-              return;
-            } else {
-              mustsReRun = false;
-              if (sameTimeQuery) {
-                useDocs = ensureNotFalsy(sameTimeQueryResult).docs;
-              }
-              var missingAmount = batchSize - useDocs.length;
-              if (missingAmount > 0) {
-                var additionalDocs = newerQueryResult.docs.slice(0, missingAmount).filter(x => !!x);
-                appendToArray(useDocs, additionalDocs);
-              }
-            }
-          });
-        }
-        if (useDocs.length === 0) {
-          return {
-            checkpoint: lastPulledCheckpoint,
-            documents: []
-          };
-        }
-        var lastDoc = ensureNotFalsy(lastOfArray(useDocs));
-        var documents = useDocs.map(row => firestoreRowToDocData(serverTimestampField, primaryPath, row));
-        var newCheckpoint = {
-          id: lastDoc.id,
-          serverTimestamp: serverTimestampToIsoString(serverTimestampField, lastDoc.data())
-        };
-        var ret = {
-          documents: documents,
-          checkpoint: newCheckpoint
-        };
-        return ret;
-      },
-      batchSize: ensureNotFalsy(options.pull).batchSize,
-      modifier: ensureNotFalsy(options.pull).modifier,
-      stream$: pullStream$.asObservable()
-    };
-  }
-  var replicationPrimitivesPush;
-  if (options.push) {
-    var pushFilter = options.push?.filter;
-    replicationPrimitivesPush = {
-      async handler(rows) {
-        if (pushFilter !== undefined) {
-          rows = await asyncFilter(rows, row => pushFilter(row.newDocumentState));
-        }
-        var writeRowsById = {};
-        var docIds = rows.map(row => {
-          var docId = row.newDocumentState[primaryPath];
-          writeRowsById[docId] = row;
-          return docId;
-        });
-        await waitForPendingWrites(options.firestore.database);
-        var conflicts = [];
-
-        /**
-         * Everything must run INSIDE of the transaction
-         * because on tx-errors, firebase will re-run the transaction on some cases.
-         * @link https://firebase.google.com/docs/firestore/manage-data/transactions#transaction_failure
-         * @link https://firebase.google.com/docs/firestore/manage-data/transactions
-         */
-        await runTransaction(options.firestore.database, async _tx => {
-          conflicts = []; // reset in case the tx has re-run.
-          /**
-           * @link https://stackoverflow.com/a/48423626/3443137
-           */
-
-          var getQuery = ids => {
-            return getDocs(query(options.firestore.collection, where(documentId(), 'in', ids)));
-          };
-          var docsInDbResult = await getContentByIds(docIds, getQuery);
-          var docsInDbById = {};
-          docsInDbResult.forEach(row => {
-            var docDataInDb = stripServerTimestampField(serverTimestampField, row.data());
-            var docId = row.id;
-            docDataInDb[primaryPath] = docId;
-            docsInDbById[docId] = docDataInDb;
-          });
-
-          /**
-           * @link https://firebase.google.com/docs/firestore/manage-data/transactions#batched-writes
-           */
-          var batch = writeBatch(options.firestore.database);
-          var hasWrite = false;
-          await Promise.all(Object.entries(writeRowsById).map(async ([docId, writeRow]) => {
-            var docInDb = docsInDbById[docId];
-            if (docInDb && (!writeRow.assumedMasterState || (await collection.conflictHandler({
-              newDocumentState: docInDb,
-              realMasterState: writeRow.assumedMasterState
-            }, 'replication-firestore-push')).isEqual === false)) {
-              // conflict
-              conflicts.push(docInDb);
-            } else {
-              // no conflict
-              hasWrite = true;
-              var docRef = doc(options.firestore.collection, docId);
-              var writeDocData = flatClone(writeRow.newDocumentState);
-              writeDocData[serverTimestampField] = serverTimestamp();
-              if (!docInDb) {
-                // insert
-                batch.set(docRef, stripPrimaryKey(primaryPath, writeDocData));
-              } else {
-                // update
-                batch.update(docRef, stripPrimaryKey(primaryPath, writeDocData));
-              }
-            }
-          }));
-          if (hasWrite) {
-            await batch.commit();
-          }
-        });
-        await waitForPendingWrites(options.firestore.database);
-        return conflicts;
-      },
-      batchSize: options.push.batchSize,
-      modifier: options.push.modifier
-    };
-  }
-  var replicationState = new RxFirestoreReplicationState(options.firestore, FIRESTORE_REPLICATION_PLUGIN_IDENTITY_PREFIX + options.collection.database.hashFunction(options.firestore.projectId), collection, replicationPrimitivesPull, replicationPrimitivesPush, options.live, options.retryTime, options.autoStart);
-
-  /**
-   * Use long polling to get live changes for the pull.stream$
-   */
-  if (options.live && options.pull) {
-    var startBefore = replicationState.start.bind(replicationState);
-    var cancelBefore = replicationState.cancel.bind(replicationState);
-    replicationState.start = () => {
-      var lastChangeQuery = query(pullQuery, orderBy(serverTimestampField, 'desc'), limit(1));
-      var unsubscribe = onSnapshot(lastChangeQuery, _querySnapshot => {
-        /**
-         * There is no good way to observe the event stream in firestore.
-         * So instead we listen to any write to the collection
-         * and then emit a 'RESYNC' flag.
-         */
-        replicationState.reSync();
-      }, error => {
-        replicationState.subjects.error.next(newRxError('RC_STREAM', {
-          error: errorToPlainJson(error)
-        }));
-      });
-      replicationState.cancel = () => {
-        unsubscribe();
-        return cancelBefore();
-      };
-      return startBefore();
-    };
-  }
-  startReplicationOnLeaderShip(options.waitForLeadership, replicationState);
-  return replicationState;
-}
-//# sourceMappingURL=index.js.map
\ No newline at end of file
diff --git a/node_modules/rxdb/dist/es/plugins/replication-firestore/index.js.map b/node_modules/rxdb/dist/es/plugins/replication-firestore/index.js.map
deleted file mode 100644
index 126466a..0000000
--- a/node_modules/rxdb/dist/es/plugins/replication-firestore/index.js.map
+++ /dev/null
@@ -1 +0,0 @@
-{"version":3,"file":"index.js","names":["appendToArray","asyncFilter","ensureNotFalsy","errorToPlainJson","flatClone","lastOfArray","toArray","doc","query","where","orderBy","limit","getDocs","onSnapshot","runTransaction","writeBatch","serverTimestamp","waitForPendingWrites","documentId","RxDBLeaderElectionPlugin","RxReplicationState","startReplicationOnLeaderShip","addRxPlugin","getSchemaByObjectPath","newRxError","Subject","firestoreRowToDocData","FIRESTORE_REPLICATION_PLUGIN_IDENTITY_PREFIX","getContentByIds","isoStringToServerTimestamp","serverTimestampToIsoString","stripPrimaryKey","stripServerTimestampField","RxFirestoreReplicationState","_RxReplicationState","_inheritsLoose","firestore","replicationIdentifierHash","collection","pull","push","live","retryTime","autoStart","_this","call","replicateFirestore","options","pullStream$","replicationPrimitivesPull","waitForLeadership","serverTimestampField","primaryPath","schema","schemaPart","jsonSchema","includes","field","pullFilters","filter","undefined","pullQuery","handler","lastPulledCheckpoint","batchSize","newerQuery","sameTimeQuery","lastServerTimestamp","id","mustsReRun","useDocs","database","_tx","newerQueryResult","sameTimeQueryResult","Promise","all","metadata","hasPendingWrites","docs","missingAmount","length","additionalDocs","slice","x","checkpoint","documents","lastDoc","map","row","newCheckpoint","data","ret","modifier","stream$","asObservable","replicationPrimitivesPush","pushFilter","rows","newDocumentState","writeRowsById","docIds","docId","conflicts","getQuery","ids","docsInDbResult","docsInDbById","forEach","docDataInDb","batch","hasWrite","Object","entries","writeRow","docInDb","assumedMasterState","conflictHandler","realMasterState","isEqual","docRef","writeDocData","set","update","commit","replicationState","hashFunction","projectId","startBefore","start","bind","cancelBefore","cancel","lastChangeQuery","unsubscribe","_querySnapshot","reSync","error","subjects","next"],"sources":["../../../../src/plugins/replication-firestore/index.ts"],"sourcesContent":["import {\n    appendToArray,\n    asyncFilter,\n    ensureNotFalsy,\n    errorToPlainJson,\n    flatClone,\n    lastOfArray,\n    toArray\n} from '../../plugins/utils';\n\nimport {\n    doc,\n    query,\n    where,\n    orderBy,\n    limit,\n    getDocs,\n    onSnapshot,\n    runTransaction,\n    writeBatch,\n    serverTimestamp,\n    QueryDocumentSnapshot,\n    waitForPendingWrites,\n    documentId\n} from 'firebase/firestore';\n\nimport { RxDBLeaderElectionPlugin } from '../leader-election';\nimport type {\n    RxCollection,\n    ReplicationPullOptions,\n    ReplicationPushOptions,\n    RxReplicationWriteToMasterRow,\n    RxReplicationPullStreamItem\n} from '../../types';\nimport {\n    RxReplicationState,\n    startReplicationOnLeaderShip\n} from '../replication';\nimport {\n    addRxPlugin,\n    ById,\n    getSchemaByObjectPath,\n    newRxError,\n    WithDeleted\n} from '../../';\n\nimport type {\n    FirestoreCheckpointType,\n    FirestoreOptions,\n    SyncOptionsFirestore\n} from './firestore-types';\nimport { Subject } from 'rxjs';\nimport {\n    firestoreRowToDocData,\n    FIRESTORE_REPLICATION_PLUGIN_IDENTITY_PREFIX,\n    getContentByIds,\n    isoStringToServerTimestamp,\n    serverTimestampToIsoString,\n    stripPrimaryKey,\n    stripServerTimestampField\n} from './firestore-helper';\n\nexport * from './firestore-helper';\nexport * from './firestore-types';\n\nexport class RxFirestoreReplicationState<RxDocType> extends RxReplicationState<RxDocType, FirestoreCheckpointType> {\n    constructor(\n        public readonly firestore: FirestoreOptions<RxDocType>,\n        public readonly replicationIdentifierHash: string,\n        public readonly collection: RxCollection<RxDocType>,\n        public readonly pull?: ReplicationPullOptions<RxDocType, FirestoreCheckpointType>,\n        public readonly push?: ReplicationPushOptions<RxDocType>,\n        public readonly live: boolean = true,\n        public retryTime: number = 1000 * 5,\n        public autoStart: boolean = true\n    ) {\n        super(\n            replicationIdentifierHash,\n            collection,\n            '_deleted',\n            pull,\n            push,\n            live,\n            retryTime,\n            autoStart\n        );\n    }\n}\n\nexport function replicateFirestore<RxDocType>(\n    options: SyncOptionsFirestore<RxDocType>\n): RxFirestoreReplicationState<RxDocType> {\n    const collection = options.collection;\n    addRxPlugin(RxDBLeaderElectionPlugin);\n    const pullStream$: Subject<RxReplicationPullStreamItem<RxDocType, FirestoreCheckpointType>> = new Subject();\n    let replicationPrimitivesPull: ReplicationPullOptions<RxDocType, FirestoreCheckpointType> | undefined;\n    options.live = typeof options.live === 'undefined' ? true : options.live;\n    options.waitForLeadership = typeof options.waitForLeadership === 'undefined' ? true : options.waitForLeadership;\n    const serverTimestampField = typeof options.serverTimestampField === 'undefined' ? 'serverTimestamp' : options.serverTimestampField;\n    options.serverTimestampField = serverTimestampField;\n    const primaryPath = collection.schema.primaryPath;\n\n    /**\n     * The serverTimestampField MUST NOT be part of the collections RxJsonSchema.\n     */\n    const schemaPart = getSchemaByObjectPath(collection.schema.jsonSchema, serverTimestampField);\n    if (\n        schemaPart ||\n        // also must not be nested.\n        serverTimestampField.includes('.')\n    ) {\n        throw newRxError('RC6', {\n            field: serverTimestampField,\n            schema: collection.schema.jsonSchema\n        });\n    }\n\n    const pullFilters = options.pull?.filter !== undefined\n        ? toArray(options.pull.filter)\n        : [];\n\n    const pullQuery = query(options.firestore.collection, ...pullFilters);\n\n    if (options.pull) {\n        replicationPrimitivesPull = {\n            async handler(\n                lastPulledCheckpoint: FirestoreCheckpointType,\n                batchSize: number\n            ) {\n                let newerQuery: ReturnType<typeof query>;\n                let sameTimeQuery: ReturnType<typeof query> | undefined;\n\n                if (lastPulledCheckpoint) {\n                    const lastServerTimestamp = isoStringToServerTimestamp(lastPulledCheckpoint.serverTimestamp);\n                    newerQuery = query(pullQuery,\n                        where(serverTimestampField, '>', lastServerTimestamp),\n                        orderBy(serverTimestampField, 'asc'),\n                        limit(batchSize)\n                    );\n                    sameTimeQuery = query(pullQuery,\n                        where(serverTimestampField, '==', lastServerTimestamp),\n                        where(primaryPath, '>', lastPulledCheckpoint.id),\n                        orderBy(primaryPath, 'asc'),\n                        limit(batchSize)\n                    );\n                } else {\n                    newerQuery = query(pullQuery,\n                        orderBy(serverTimestampField, 'asc'),\n                        limit(batchSize)\n                    );\n                }\n\n                let mustsReRun = true;\n                let useDocs: QueryDocumentSnapshot<RxDocType>[] = [];\n                while (mustsReRun) {\n                    /**\n                     * Local writes that have not been persisted to the server\n                     * are in pending state and do not have a correct serverTimestamp set.\n                     * We have to ensure we only use document states that are in sync with the server.\n                     * @link https://medium.com/firebase-developers/the-secrets-of-firestore-fieldvalue-servertimestamp-revealed-29dd7a38a82b\n                     */\n                    await waitForPendingWrites(options.firestore.database);\n                    await runTransaction(options.firestore.database, async (_tx) => {\n                        useDocs = [];\n                        const [\n                            newerQueryResult,\n                            sameTimeQueryResult\n                        ] = await Promise.all([\n                            getDocs(newerQuery),\n                            sameTimeQuery ? getDocs(sameTimeQuery) : undefined\n                        ]);\n\n                        if (\n                            newerQueryResult.metadata.hasPendingWrites ||\n                            (sameTimeQuery && ensureNotFalsy(sameTimeQueryResult).metadata.hasPendingWrites)\n                        ) {\n                            return;\n                        } else {\n                            mustsReRun = false;\n\n                            if (sameTimeQuery) {\n                                useDocs = ensureNotFalsy(sameTimeQueryResult).docs as any;\n                            }\n                            const missingAmount = batchSize - useDocs.length;\n                            if (missingAmount > 0) {\n                                const additionalDocs = newerQueryResult.docs.slice(0, missingAmount).filter(x => !!x);\n                                appendToArray(useDocs, additionalDocs);\n                            }\n                        }\n                    });\n                }\n\n                if (useDocs.length === 0) {\n                    return {\n                        checkpoint: lastPulledCheckpoint,\n                        documents: []\n                    };\n                }\n                const lastDoc = ensureNotFalsy(lastOfArray(useDocs));\n                const documents: WithDeleted<RxDocType>[] = useDocs\n                    .map(row => firestoreRowToDocData(\n                        serverTimestampField,\n                        primaryPath,\n                        row\n                    ));\n                const newCheckpoint: FirestoreCheckpointType = {\n                    id: lastDoc.id,\n                    serverTimestamp: serverTimestampToIsoString(serverTimestampField, lastDoc.data())\n                };\n                const ret = {\n                    documents: documents,\n                    checkpoint: newCheckpoint\n                };\n                return ret;\n            },\n            batchSize: ensureNotFalsy(options.pull).batchSize,\n            modifier: ensureNotFalsy(options.pull).modifier,\n            stream$: pullStream$.asObservable()\n        };\n    }\n\n    let replicationPrimitivesPush: ReplicationPushOptions<RxDocType> | undefined;\n    if (options.push) {\n        const pushFilter = options.push?.filter;\n        replicationPrimitivesPush = {\n            async handler(\n                rows: RxReplicationWriteToMasterRow<RxDocType>[]\n            ) {\n                if (pushFilter !== undefined) {\n                    rows = await asyncFilter(rows, (row) => pushFilter(row.newDocumentState));\n                }\n\n                const writeRowsById: ById<RxReplicationWriteToMasterRow<RxDocType>> = {};\n                const docIds: string[] = rows.map(row => {\n                    const docId = (row.newDocumentState as any)[primaryPath];\n                    writeRowsById[docId] = row;\n                    return docId;\n                });\n                await waitForPendingWrites(options.firestore.database);\n                let conflicts: WithDeleted<RxDocType>[] = [];\n\n                /**\n                 * Everything must run INSIDE of the transaction\n                 * because on tx-errors, firebase will re-run the transaction on some cases.\n                 * @link https://firebase.google.com/docs/firestore/manage-data/transactions#transaction_failure\n                 * @link https://firebase.google.com/docs/firestore/manage-data/transactions\n                 */\n                await runTransaction(options.firestore.database, async (_tx) => {\n                    conflicts = []; // reset in case the tx has re-run.\n                    /**\n                     * @link https://stackoverflow.com/a/48423626/3443137\n                     */\n\n                    const getQuery = (ids: string[]) => {\n                        return getDocs(\n                            query(\n                                options.firestore.collection,\n                                where(documentId(), 'in', ids)\n                            )\n                        );\n                    };\n\n                    const docsInDbResult = await getContentByIds<RxDocType>(docIds, getQuery);\n\n                    const docsInDbById: ById<RxDocType> = {};\n                    docsInDbResult.forEach(row => {\n                        const docDataInDb = stripServerTimestampField(serverTimestampField, row.data());\n                        const docId = row.id;\n                        (docDataInDb as any)[primaryPath] = docId;\n                        docsInDbById[docId] = docDataInDb;\n                    });\n\n                    /**\n                     * @link https://firebase.google.com/docs/firestore/manage-data/transactions#batched-writes\n                     */\n                    const batch = writeBatch(options.firestore.database);\n                    let hasWrite = false;\n                    await Promise.all(\n                        Object.entries(writeRowsById).map(async ([docId, writeRow]) => {\n                            const docInDb: RxDocType | undefined = docsInDbById[docId];\n\n                            if (\n                                docInDb &&\n                                (\n                                    !writeRow.assumedMasterState ||\n                                    (await collection.conflictHandler({\n                                        newDocumentState: docInDb as any,\n                                        realMasterState: writeRow.assumedMasterState\n                                    }, 'replication-firestore-push')).isEqual === false\n                                )\n                            ) {\n                                // conflict\n                                conflicts.push(docInDb as any);\n                            } else {\n                                // no conflict\n                                hasWrite = true;\n                                const docRef = doc(options.firestore.collection, docId);\n                                const writeDocData = flatClone(writeRow.newDocumentState);\n                                (writeDocData as any)[serverTimestampField] = serverTimestamp();\n                                if (!docInDb) {\n                                    // insert\n                                    batch.set(docRef, stripPrimaryKey(primaryPath, writeDocData));\n                                } else {\n                                    // update\n                                    batch.update(docRef, stripPrimaryKey(primaryPath, writeDocData));\n                                }\n                            }\n                        })\n                    );\n\n                    if (hasWrite) {\n                        await batch.commit();\n                    }\n                });\n                await waitForPendingWrites(options.firestore.database);\n                return conflicts;\n            },\n            batchSize: options.push.batchSize,\n            modifier: options.push.modifier\n        };\n    }\n\n\n    const replicationState = new RxFirestoreReplicationState<RxDocType>(\n        options.firestore,\n        FIRESTORE_REPLICATION_PLUGIN_IDENTITY_PREFIX + options.collection.database.hashFunction(options.firestore.projectId),\n        collection,\n        replicationPrimitivesPull,\n        replicationPrimitivesPush,\n        options.live,\n        options.retryTime,\n        options.autoStart\n    );\n\n    /**\n     * Use long polling to get live changes for the pull.stream$\n     */\n    if (options.live && options.pull) {\n        const startBefore = replicationState.start.bind(replicationState);\n        const cancelBefore = replicationState.cancel.bind(replicationState);\n        replicationState.start = () => {\n            const lastChangeQuery = query(\n                pullQuery,\n                orderBy(serverTimestampField, 'desc'),\n                limit(1)\n            );\n            const unsubscribe = onSnapshot(\n                lastChangeQuery,\n                (_querySnapshot) => {\n                    /**\n                     * There is no good way to observe the event stream in firestore.\n                     * So instead we listen to any write to the collection\n                     * and then emit a 'RESYNC' flag.\n                     */\n                    replicationState.reSync();\n                },\n                (error) => {\n                    replicationState.subjects.error.next(\n                        newRxError('RC_STREAM', { error: errorToPlainJson(error) })\n                    );\n                }\n            );\n            replicationState.cancel = () => {\n                unsubscribe();\n                return cancelBefore();\n            };\n            return startBefore();\n        };\n    }\n\n    startReplicationOnLeaderShip(options.waitForLeadership, replicationState);\n\n    return replicationState;\n}\n"],"mappings":";AAAA,SACIA,aAAa,EACbC,WAAW,EACXC,cAAc,EACdC,gBAAgB,EAChBC,SAAS,EACTC,WAAW,EACXC,OAAO,QACJ,qBAAqB;AAE5B,SACIC,GAAG,EACHC,KAAK,EACLC,KAAK,EACLC,OAAO,EACPC,KAAK,EACLC,OAAO,EACPC,UAAU,EACVC,cAAc,EACdC,UAAU,EACVC,eAAe,EAEfC,oBAAoB,EACpBC,UAAU,QACP,oBAAoB;AAE3B,SAASC,wBAAwB,QAAQ,oBAAoB;AAQ7D,SACIC,kBAAkB,EAClBC,4BAA4B,QACzB,gBAAgB;AACvB,SACIC,WAAW,EAEXC,qBAAqB,EACrBC,UAAU,QAEP,QAAQ;AAOf,SAASC,OAAO,QAAQ,MAAM;AAC9B,SACIC,qBAAqB,EACrBC,4CAA4C,EAC5CC,eAAe,EACfC,0BAA0B,EAC1BC,0BAA0B,EAC1BC,eAAe,EACfC,yBAAyB,QACtB,oBAAoB;AAE3B,cAAc,oBAAoB;AAClC,cAAc,mBAAmB;AAEjC,WAAaC,2BAA2B,0BAAAC,mBAAA;EAAAC,cAAA,CAAAF,2BAAA,EAAAC,mBAAA;EACpC,SAAAD,4BACoBG,SAAsC,EACtCC,yBAAiC,EACjCC,UAAmC,EACnCC,IAAiE,EACjEC,IAAwC,EACxCC,IAAa,GAAG,IAAI,EAC7BC,SAAiB,GAAG,IAAI,GAAG,CAAC,EAC5BC,SAAkB,GAAG,IAAI,EAClC;IAAA,IAAAC,KAAA;IACEA,KAAA,GAAAV,mBAAA,CAAAW,IAAA,OACIR,yBAAyB,EACzBC,UAAU,EACV,UAAU,EACVC,IAAI,EACJC,IAAI,EACJC,IAAI,EACJC,SAAS,EACTC,SACJ,CAAC;IAACC,KAAA,CAlBcR,SAAsC,GAAtCA,SAAsC;IAAAQ,KAAA,CACtCP,yBAAiC,GAAjCA,yBAAiC;IAAAO,KAAA,CACjCN,UAAmC,GAAnCA,UAAmC;IAAAM,KAAA,CACnCL,IAAiE,GAAjEA,IAAiE;IAAAK,KAAA,CACjEJ,IAAwC,GAAxCA,IAAwC;IAAAI,KAAA,CACxCH,IAAa,GAAbA,IAAa;IAAAG,KAAA,CACtBF,SAAiB,GAAjBA,SAAiB;IAAAE,KAAA,CACjBD,SAAkB,GAAlBA,SAAkB;IAAA,OAAAC,KAAA;EAY7B;EAAC,OAAAX,2BAAA;AAAA,EArBuDb,kBAAkB;AAwB9E,OAAO,SAAS0B,kBAAkBA,CAC9BC,OAAwC,EACF;EACtC,IAAMT,UAAU,GAAGS,OAAO,CAACT,UAAU;EACrChB,WAAW,CAACH,wBAAwB,CAAC;EACrC,IAAM6B,WAAqF,GAAG,IAAIvB,OAAO,CAAC,CAAC;EAC3G,IAAIwB,yBAAiG;EACrGF,OAAO,CAACN,IAAI,GAAG,OAAOM,OAAO,CAACN,IAAI,KAAK,WAAW,GAAG,IAAI,GAAGM,OAAO,CAACN,IAAI;EACxEM,OAAO,CAACG,iBAAiB,GAAG,OAAOH,OAAO,CAACG,iBAAiB,KAAK,WAAW,GAAG,IAAI,GAAGH,OAAO,CAACG,iBAAiB;EAC/G,IAAMC,oBAAoB,GAAG,OAAOJ,OAAO,CAACI,oBAAoB,KAAK,WAAW,GAAG,iBAAiB,GAAGJ,OAAO,CAACI,oBAAoB;EACnIJ,OAAO,CAACI,oBAAoB,GAAGA,oBAAoB;EACnD,IAAMC,WAAW,GAAGd,UAAU,CAACe,MAAM,CAACD,WAAW;;EAEjD;AACJ;AACA;EACI,IAAME,UAAU,GAAG/B,qBAAqB,CAACe,UAAU,CAACe,MAAM,CAACE,UAAU,EAAEJ,oBAAoB,CAAC;EAC5F,IACIG,UAAU;EACV;EACAH,oBAAoB,CAACK,QAAQ,CAAC,GAAG,CAAC,EACpC;IACE,MAAMhC,UAAU,CAAC,KAAK,EAAE;MACpBiC,KAAK,EAAEN,oBAAoB;MAC3BE,MAAM,EAAEf,UAAU,CAACe,MAAM,CAACE;IAC9B,CAAC,CAAC;EACN;EAEA,IAAMG,WAAW,GAAGX,OAAO,CAACR,IAAI,EAAEoB,MAAM,KAAKC,SAAS,GAChDtD,OAAO,CAACyC,OAAO,CAACR,IAAI,CAACoB,MAAM,CAAC,GAC5B,EAAE;EAER,IAAME,SAAS,GAAGrD,KAAK,CAACuC,OAAO,CAACX,SAAS,CAACE,UAAU,EAAE,GAAGoB,WAAW,CAAC;EAErE,IAAIX,OAAO,CAACR,IAAI,EAAE;IACdU,yBAAyB,GAAG;MACxB,MAAMa,OAAOA,CACTC,oBAA6C,EAC7CC,SAAiB,EACnB;QACE,IAAIC,UAAoC;QACxC,IAAIC,aAAmD;QAEvD,IAAIH,oBAAoB,EAAE;UACtB,IAAMI,mBAAmB,GAAGtC,0BAA0B,CAACkC,oBAAoB,CAAC/C,eAAe,CAAC;UAC5FiD,UAAU,GAAGzD,KAAK,CAACqD,SAAS,EACxBpD,KAAK,CAAC0C,oBAAoB,EAAE,GAAG,EAAEgB,mBAAmB,CAAC,EACrDzD,OAAO,CAACyC,oBAAoB,EAAE,KAAK,CAAC,EACpCxC,KAAK,CAACqD,SAAS,CACnB,CAAC;UACDE,aAAa,GAAG1D,KAAK,CAACqD,SAAS,EAC3BpD,KAAK,CAAC0C,oBAAoB,EAAE,IAAI,EAAEgB,mBAAmB,CAAC,EACtD1D,KAAK,CAAC2C,WAAW,EAAE,GAAG,EAAEW,oBAAoB,CAACK,EAAE,CAAC,EAChD1D,OAAO,CAAC0C,WAAW,EAAE,KAAK,CAAC,EAC3BzC,KAAK,CAACqD,SAAS,CACnB,CAAC;QACL,CAAC,MAAM;UACHC,UAAU,GAAGzD,KAAK,CAACqD,SAAS,EACxBnD,OAAO,CAACyC,oBAAoB,EAAE,KAAK,CAAC,EACpCxC,KAAK,CAACqD,SAAS,CACnB,CAAC;QACL;QAEA,IAAIK,UAAU,GAAG,IAAI;QACrB,IAAIC,OAA2C,GAAG,EAAE;QACpD,OAAOD,UAAU,EAAE;UACf;AACpB;AACA;AACA;AACA;AACA;UACoB,MAAMpD,oBAAoB,CAAC8B,OAAO,CAACX,SAAS,CAACmC,QAAQ,CAAC;UACtD,MAAMzD,cAAc,CAACiC,OAAO,CAACX,SAAS,CAACmC,QAAQ,EAAE,MAAOC,GAAG,IAAK;YAC5DF,OAAO,GAAG,EAAE;YACZ,IAAM,CACFG,gBAAgB,EAChBC,mBAAmB,CACtB,GAAG,MAAMC,OAAO,CAACC,GAAG,CAAC,CAClBhE,OAAO,CAACqD,UAAU,CAAC,EACnBC,aAAa,GAAGtD,OAAO,CAACsD,aAAa,CAAC,GAAGN,SAAS,CACrD,CAAC;YAEF,IACIa,gBAAgB,CAACI,QAAQ,CAACC,gBAAgB,IACzCZ,aAAa,IAAIhE,cAAc,CAACwE,mBAAmB,CAAC,CAACG,QAAQ,CAACC,gBAAiB,EAClF;cACE;YACJ,CAAC,MAAM;cACHT,UAAU,GAAG,KAAK;cAElB,IAAIH,aAAa,EAAE;gBACfI,OAAO,GAAGpE,cAAc,CAACwE,mBAAmB,CAAC,CAACK,IAAW;cAC7D;cACA,IAAMC,aAAa,GAAGhB,SAAS,GAAGM,OAAO,CAACW,MAAM;cAChD,IAAID,aAAa,GAAG,CAAC,EAAE;gBACnB,IAAME,cAAc,GAAGT,gBAAgB,CAACM,IAAI,CAACI,KAAK,CAAC,CAAC,EAAEH,aAAa,CAAC,CAACrB,MAAM,CAACyB,CAAC,IAAI,CAAC,CAACA,CAAC,CAAC;gBACrFpF,aAAa,CAACsE,OAAO,EAAEY,cAAc,CAAC;cAC1C;YACJ;UACJ,CAAC,CAAC;QACN;QAEA,IAAIZ,OAAO,CAACW,MAAM,KAAK,CAAC,EAAE;UACtB,OAAO;YACHI,UAAU,EAAEtB,oBAAoB;YAChCuB,SAAS,EAAE;UACf,CAAC;QACL;QACA,IAAMC,OAAO,GAAGrF,cAAc,CAACG,WAAW,CAACiE,OAAO,CAAC,CAAC;QACpD,IAAMgB,SAAmC,GAAGhB,OAAO,CAC9CkB,GAAG,CAACC,GAAG,IAAI/D,qBAAqB,CAC7ByB,oBAAoB,EACpBC,WAAW,EACXqC,GACJ,CAAC,CAAC;QACN,IAAMC,aAAsC,GAAG;UAC3CtB,EAAE,EAAEmB,OAAO,CAACnB,EAAE;UACdpD,eAAe,EAAEc,0BAA0B,CAACqB,oBAAoB,EAAEoC,OAAO,CAACI,IAAI,CAAC,CAAC;QACpF,CAAC;QACD,IAAMC,GAAG,GAAG;UACRN,SAAS,EAAEA,SAAS;UACpBD,UAAU,EAAEK;QAChB,CAAC;QACD,OAAOE,GAAG;MACd,CAAC;MACD5B,SAAS,EAAE9D,cAAc,CAAC6C,OAAO,CAACR,IAAI,CAAC,CAACyB,SAAS;MACjD6B,QAAQ,EAAE3F,cAAc,CAAC6C,OAAO,CAACR,IAAI,CAAC,CAACsD,QAAQ;MAC/CC,OAAO,EAAE9C,WAAW,CAAC+C,YAAY,CAAC;IACtC,CAAC;EACL;EAEA,IAAIC,yBAAwE;EAC5E,IAAIjD,OAAO,CAACP,IAAI,EAAE;IACd,IAAMyD,UAAU,GAAGlD,OAAO,CAACP,IAAI,EAAEmB,MAAM;IACvCqC,yBAAyB,GAAG;MACxB,MAAMlC,OAAOA,CACToC,IAAgD,EAClD;QACE,IAAID,UAAU,KAAKrC,SAAS,EAAE;UAC1BsC,IAAI,GAAG,MAAMjG,WAAW,CAACiG,IAAI,EAAGT,GAAG,IAAKQ,UAAU,CAACR,GAAG,CAACU,gBAAgB,CAAC,CAAC;QAC7E;QAEA,IAAMC,aAA6D,GAAG,CAAC,CAAC;QACxE,IAAMC,MAAgB,GAAGH,IAAI,CAACV,GAAG,CAACC,GAAG,IAAI;UACrC,IAAMa,KAAK,GAAIb,GAAG,CAACU,gBAAgB,CAAS/C,WAAW,CAAC;UACxDgD,aAAa,CAACE,KAAK,CAAC,GAAGb,GAAG;UAC1B,OAAOa,KAAK;QAChB,CAAC,CAAC;QACF,MAAMrF,oBAAoB,CAAC8B,OAAO,CAACX,SAAS,CAACmC,QAAQ,CAAC;QACtD,IAAIgC,SAAmC,GAAG,EAAE;;QAE5C;AAChB;AACA;AACA;AACA;AACA;QACgB,MAAMzF,cAAc,CAACiC,OAAO,CAACX,SAAS,CAACmC,QAAQ,EAAE,MAAOC,GAAG,IAAK;UAC5D+B,SAAS,GAAG,EAAE,CAAC,CAAC;UAChB;AACpB;AACA;;UAEoB,IAAMC,QAAQ,GAAIC,GAAa,IAAK;YAChC,OAAO7F,OAAO,CACVJ,KAAK,CACDuC,OAAO,CAACX,SAAS,CAACE,UAAU,EAC5B7B,KAAK,CAACS,UAAU,CAAC,CAAC,EAAE,IAAI,EAAEuF,GAAG,CACjC,CACJ,CAAC;UACL,CAAC;UAED,IAAMC,cAAc,GAAG,MAAM9E,eAAe,CAAYyE,MAAM,EAAEG,QAAQ,CAAC;UAEzE,IAAMG,YAA6B,GAAG,CAAC,CAAC;UACxCD,cAAc,CAACE,OAAO,CAACnB,GAAG,IAAI;YAC1B,IAAMoB,WAAW,GAAG7E,yBAAyB,CAACmB,oBAAoB,EAAEsC,GAAG,CAACE,IAAI,CAAC,CAAC,CAAC;YAC/E,IAAMW,KAAK,GAAGb,GAAG,CAACrB,EAAE;YACnByC,WAAW,CAASzD,WAAW,CAAC,GAAGkD,KAAK;YACzCK,YAAY,CAACL,KAAK,CAAC,GAAGO,WAAW;UACrC,CAAC,CAAC;;UAEF;AACpB;AACA;UACoB,IAAMC,KAAK,GAAG/F,UAAU,CAACgC,OAAO,CAACX,SAAS,CAACmC,QAAQ,CAAC;UACpD,IAAIwC,QAAQ,GAAG,KAAK;UACpB,MAAMpC,OAAO,CAACC,GAAG,CACboC,MAAM,CAACC,OAAO,CAACb,aAAa,CAAC,CAACZ,GAAG,CAAC,OAAO,CAACc,KAAK,EAAEY,QAAQ,CAAC,KAAK;YAC3D,IAAMC,OAA8B,GAAGR,YAAY,CAACL,KAAK,CAAC;YAE1D,IACIa,OAAO,KAEH,CAACD,QAAQ,CAACE,kBAAkB,IAC5B,CAAC,MAAM9E,UAAU,CAAC+E,eAAe,CAAC;cAC9BlB,gBAAgB,EAAEgB,OAAc;cAChCG,eAAe,EAAEJ,QAAQ,CAACE;YAC9B,CAAC,EAAE,4BAA4B,CAAC,EAAEG,OAAO,KAAK,KAAK,CACtD,EACH;cACE;cACAhB,SAAS,CAAC/D,IAAI,CAAC2E,OAAc,CAAC;YAClC,CAAC,MAAM;cACH;cACAJ,QAAQ,GAAG,IAAI;cACf,IAAMS,MAAM,GAAGjH,GAAG,CAACwC,OAAO,CAACX,SAAS,CAACE,UAAU,EAAEgE,KAAK,CAAC;cACvD,IAAMmB,YAAY,GAAGrH,SAAS,CAAC8G,QAAQ,CAACf,gBAAgB,CAAC;cACxDsB,YAAY,CAAStE,oBAAoB,CAAC,GAAGnC,eAAe,CAAC,CAAC;cAC/D,IAAI,CAACmG,OAAO,EAAE;gBACV;gBACAL,KAAK,CAACY,GAAG,CAACF,MAAM,EAAEzF,eAAe,CAACqB,WAAW,EAAEqE,YAAY,CAAC,CAAC;cACjE,CAAC,MAAM;gBACH;gBACAX,KAAK,CAACa,MAAM,CAACH,MAAM,EAAEzF,eAAe,CAACqB,WAAW,EAAEqE,YAAY,CAAC,CAAC;cACpE;YACJ;UACJ,CAAC,CACL,CAAC;UAED,IAAIV,QAAQ,EAAE;YACV,MAAMD,KAAK,CAACc,MAAM,CAAC,CAAC;UACxB;QACJ,CAAC,CAAC;QACF,MAAM3G,oBAAoB,CAAC8B,OAAO,CAACX,SAAS,CAACmC,QAAQ,CAAC;QACtD,OAAOgC,SAAS;MACpB,CAAC;MACDvC,SAAS,EAAEjB,OAAO,CAACP,IAAI,CAACwB,SAAS;MACjC6B,QAAQ,EAAE9C,OAAO,CAACP,IAAI,CAACqD;IAC3B,CAAC;EACL;EAGA,IAAMgC,gBAAgB,GAAG,IAAI5F,2BAA2B,CACpDc,OAAO,CAACX,SAAS,EACjBT,4CAA4C,GAAGoB,OAAO,CAACT,UAAU,CAACiC,QAAQ,CAACuD,YAAY,CAAC/E,OAAO,CAACX,SAAS,CAAC2F,SAAS,CAAC,EACpHzF,UAAU,EACVW,yBAAyB,EACzB+C,yBAAyB,EACzBjD,OAAO,CAACN,IAAI,EACZM,OAAO,CAACL,SAAS,EACjBK,OAAO,CAACJ,SACZ,CAAC;;EAED;AACJ;AACA;EACI,IAAII,OAAO,CAACN,IAAI,IAAIM,OAAO,CAACR,IAAI,EAAE;IAC9B,IAAMyF,WAAW,GAAGH,gBAAgB,CAACI,KAAK,CAACC,IAAI,CAACL,gBAAgB,CAAC;IACjE,IAAMM,YAAY,GAAGN,gBAAgB,CAACO,MAAM,CAACF,IAAI,CAACL,gBAAgB,CAAC;IACnEA,gBAAgB,CAACI,KAAK,GAAG,MAAM;MAC3B,IAAMI,eAAe,GAAG7H,KAAK,CACzBqD,SAAS,EACTnD,OAAO,CAACyC,oBAAoB,EAAE,MAAM,CAAC,EACrCxC,KAAK,CAAC,CAAC,CACX,CAAC;MACD,IAAM2H,WAAW,GAAGzH,UAAU,CAC1BwH,eAAe,EACdE,cAAc,IAAK;QAChB;AACpB;AACA;AACA;AACA;QACoBV,gBAAgB,CAACW,MAAM,CAAC,CAAC;MAC7B,CAAC,EACAC,KAAK,IAAK;QACPZ,gBAAgB,CAACa,QAAQ,CAACD,KAAK,CAACE,IAAI,CAChCnH,UAAU,CAAC,WAAW,EAAE;UAAEiH,KAAK,EAAEtI,gBAAgB,CAACsI,KAAK;QAAE,CAAC,CAC9D,CAAC;MACL,CACJ,CAAC;MACDZ,gBAAgB,CAACO,MAAM,GAAG,MAAM;QAC5BE,WAAW,CAAC,CAAC;QACb,OAAOH,YAAY,CAAC,CAAC;MACzB,CAAC;MACD,OAAOH,WAAW,CAAC,CAAC;IACxB,CAAC;EACL;EAEA3G,4BAA4B,CAAC0B,OAAO,CAACG,iBAAiB,EAAE2E,gBAAgB,CAAC;EAEzE,OAAOA,gBAAgB;AAC3B"}
\ No newline at end of file
diff --git a/node_modules/rxdb/dist/lib/plugins/encryption-crypto-js/index.js b/node_modules/rxdb/dist/lib/plugins/encryption-crypto-js/index.js
deleted file mode 100644
index 1e5c74c..0000000
--- a/node_modules/rxdb/dist/lib/plugins/encryption-crypto-js/index.js
+++ /dev/null
@@ -1,147 +0,0 @@
-"use strict";
-
-var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
-Object.defineProperty(exports, "__esModule", {
-  value: true
-});
-exports.MINIMUM_PASSWORD_LENGTH = void 0;
-exports.decryptString = decryptString;
-exports.encryptString = encryptString;
-exports.wrappedKeyEncryptionCryptoJsStorage = wrappedKeyEncryptionCryptoJsStorage;
-var _aes = _interopRequireDefault(require("crypto-js/aes"));
-var cryptoEnc = _interopRequireWildcard(require("crypto-js/enc-utf8"));
-var _pluginHelpers = require("../../plugin-helpers");
-var _rxError = require("../../rx-error");
-var _rxStorageHelper = require("../../rx-storage-helper");
-var _utils = require("../../plugins/utils");
-function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
-function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
-/**
- * this plugin adds the encryption-capabilities to rxdb
- * It's using crypto-js/aes for password-encryption
- * @link https://github.com/brix/crypto-js
- */
-
-var MINIMUM_PASSWORD_LENGTH = 8;
-exports.MINIMUM_PASSWORD_LENGTH = MINIMUM_PASSWORD_LENGTH;
-function encryptString(value, password) {
-  var encrypted = _aes.default.encrypt(value, password);
-  return encrypted.toString();
-}
-function decryptString(cipherText, password) {
-  /**
-   * Trying to decrypt non-strings
-   * will cause no errors and will be hard to debug.
-   * So instead we do this check here.
-   */
-  if (typeof cipherText !== 'string') {
-    throw (0, _rxError.newRxError)('SNH', {
-      args: {
-        cipherText
-      }
-    });
-  }
-  var decrypted = _aes.default.decrypt(cipherText, password);
-  var ret = decrypted.toString(cryptoEnc);
-  return ret;
-}
-function wrappedKeyEncryptionCryptoJsStorage(args) {
-  return Object.assign({}, args.storage, {
-    async createStorageInstance(params) {
-      if (typeof params.password !== 'undefined') {
-        validatePassword(params.password);
-      }
-      if (!(0, _rxStorageHelper.hasEncryption)(params.schema)) {
-        var retInstance = await args.storage.createStorageInstance(params);
-        return retInstance;
-      }
-      if (!params.password) {
-        throw (0, _rxError.newRxError)('EN3', {
-          database: params.databaseName,
-          collection: params.collectionName,
-          schema: params.schema
-        });
-      }
-      var password = params.password;
-      var schemaWithoutEncrypted = (0, _utils.clone)(params.schema);
-      delete schemaWithoutEncrypted.encrypted;
-      if (schemaWithoutEncrypted.attachments) {
-        schemaWithoutEncrypted.attachments.encrypted = false;
-      }
-      var instance = await args.storage.createStorageInstance(Object.assign({}, params, {
-        schema: schemaWithoutEncrypted
-      }));
-      function modifyToStorage(docData) {
-        docData = cloneWithoutAttachments(docData);
-        (0, _utils.ensureNotFalsy)(params.schema.encrypted).forEach(path => {
-          var value = (0, _utils.getProperty)(docData, path);
-          if (typeof value === 'undefined') {
-            return;
-          }
-          var stringValue = JSON.stringify(value);
-          var encrypted = encryptString(stringValue, password);
-          (0, _utils.setProperty)(docData, path, encrypted);
-        });
-
-        // handle attachments
-        if (params.schema.attachments && params.schema.attachments.encrypted) {
-          var newAttachments = {};
-          Object.entries(docData._attachments).forEach(([id, attachment]) => {
-            var useAttachment = (0, _utils.flatClone)(attachment);
-            if (useAttachment.data) {
-              var dataString = useAttachment.data;
-              useAttachment.data = (0, _utils.b64EncodeUnicode)(encryptString(dataString, password));
-            }
-            newAttachments[id] = useAttachment;
-          });
-          docData._attachments = newAttachments;
-        }
-        return docData;
-      }
-      function modifyFromStorage(docData) {
-        docData = cloneWithoutAttachments(docData);
-        (0, _utils.ensureNotFalsy)(params.schema.encrypted).forEach(path => {
-          var value = (0, _utils.getProperty)(docData, path);
-          if (typeof value === 'undefined') {
-            return;
-          }
-          var decrypted = decryptString(value, password);
-          var decryptedParsed = JSON.parse(decrypted);
-          (0, _utils.setProperty)(docData, path, decryptedParsed);
-        });
-        return docData;
-      }
-      function modifyAttachmentFromStorage(attachmentData) {
-        if (params.schema.attachments && params.schema.attachments.encrypted) {
-          var decrypted = decryptString((0, _utils.b64DecodeUnicode)(attachmentData), password);
-          return decrypted;
-        } else {
-          return attachmentData;
-        }
-      }
-      return (0, _pluginHelpers.wrapRxStorageInstance)(instance, modifyToStorage, modifyFromStorage, modifyAttachmentFromStorage);
-    }
-  });
-}
-function cloneWithoutAttachments(data) {
-  var attachments = data._attachments;
-  data = (0, _utils.flatClone)(data);
-  delete data._attachments;
-  data = (0, _utils.clone)(data);
-  data._attachments = attachments;
-  return data;
-}
-function validatePassword(password) {
-  if (typeof password !== 'string') {
-    throw (0, _rxError.newRxTypeError)('EN1', {
-      password
-    });
-  }
-  if (password.length < MINIMUM_PASSWORD_LENGTH) {
-    throw (0, _rxError.newRxError)('EN2', {
-      minPassLength: MINIMUM_PASSWORD_LENGTH,
-      password
-    });
-  }
-}
-//# sourceMappingURL=index.js.map
\ No newline at end of file
diff --git a/node_modules/rxdb/dist/lib/plugins/encryption-crypto-js/index.js.map b/node_modules/rxdb/dist/lib/plugins/encryption-crypto-js/index.js.map
deleted file mode 100644
index d7bada8..0000000
--- a/node_modules/rxdb/dist/lib/plugins/encryption-crypto-js/index.js.map
+++ /dev/null
@@ -1 +0,0 @@
-{"version":3,"file":"index.js","names":["_aes","_interopRequireDefault","require","cryptoEnc","_interopRequireWildcard","_pluginHelpers","_rxError","_rxStorageHelper","_utils","_getRequireWildcardCache","nodeInterop","WeakMap","cacheBabelInterop","cacheNodeInterop","obj","__esModule","default","cache","has","get","newObj","hasPropertyDescriptor","Object","defineProperty","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","MINIMUM_PASSWORD_LENGTH","exports","encryptString","value","password","encrypted","AES","encrypt","toString","decryptString","cipherText","newRxError","args","decrypted","decrypt","ret","wrappedKeyEncryptionCryptoJsStorage","assign","storage","createStorageInstance","params","validatePassword","hasEncryption","schema","retInstance","database","databaseName","collection","collectionName","schemaWithoutEncrypted","clone","attachments","instance","modifyToStorage","docData","cloneWithoutAttachments","ensureNotFalsy","forEach","path","getProperty","stringValue","JSON","stringify","setProperty","newAttachments","entries","_attachments","id","attachment","useAttachment","flatClone","data","dataString","b64EncodeUnicode","modifyFromStorage","decryptedParsed","parse","modifyAttachmentFromStorage","attachmentData","b64DecodeUnicode","wrapRxStorageInstance","newRxTypeError","length","minPassLength"],"sources":["../../../../src/plugins/encryption-crypto-js/index.ts"],"sourcesContent":["/**\n * this plugin adds the encryption-capabilities to rxdb\n * It's using crypto-js/aes for password-encryption\n * @link https://github.com/brix/crypto-js\n */\nimport AES from 'crypto-js/aes';\nimport * as cryptoEnc from 'crypto-js/enc-utf8';\nimport { wrapRxStorageInstance } from '../../plugin-helpers';\nimport { newRxError, newRxTypeError } from '../../rx-error';\nimport { hasEncryption } from '../../rx-storage-helper';\nimport type {\n    InternalStoreDocType,\n    RxAttachmentWriteData,\n    RxDocumentData,\n    RxDocumentWriteData,\n    RxJsonSchema,\n    RxStorage,\n    RxStorageInstanceCreationParams\n} from '../../types';\nimport {\n    b64DecodeUnicode,\n    b64EncodeUnicode,\n    clone,\n    ensureNotFalsy,\n    flatClone,\n    getProperty,\n    setProperty\n} from '../../plugins/utils';\n\nexport const MINIMUM_PASSWORD_LENGTH: 8 = 8;\n\n\nexport function encryptString(value: string, password: string): string {\n    const encrypted = AES.encrypt(value, password);\n    return encrypted.toString();\n}\n\nexport function decryptString(cipherText: string, password: any): string {\n    /**\n     * Trying to decrypt non-strings\n     * will cause no errors and will be hard to debug.\n     * So instead we do this check here.\n     */\n    if (typeof cipherText !== 'string') {\n        throw newRxError('SNH', {\n            args: {\n                cipherText\n            }\n        });\n    }\n\n    const decrypted = AES.decrypt(cipherText, password);\n    const ret = decrypted.toString(cryptoEnc);\n    return ret;\n}\n\nexport type InternalStorePasswordDocType = InternalStoreDocType<{\n    hash: string;\n}>;\n\nexport function wrappedKeyEncryptionCryptoJsStorage<Internals, InstanceCreationOptions>(\n    args: {\n        storage: RxStorage<Internals, InstanceCreationOptions>;\n    }\n): RxStorage<Internals, InstanceCreationOptions> {\n    return Object.assign(\n        {},\n        args.storage,\n        {\n            async createStorageInstance<RxDocType>(\n                params: RxStorageInstanceCreationParams<RxDocType, any>\n            ) {\n                if (typeof params.password !== 'undefined') {\n                    validatePassword(params.password as any);\n                }\n\n                if (!hasEncryption(params.schema)) {\n                    const retInstance = await args.storage.createStorageInstance(params);\n                    return retInstance;\n                }\n\n                if (!params.password) {\n                    throw newRxError('EN3', {\n                        database: params.databaseName,\n                        collection: params.collectionName,\n                        schema: params.schema\n                    });\n                }\n                const password = params.password;\n\n                const schemaWithoutEncrypted: RxJsonSchema<RxDocumentData<RxDocType>> = clone(params.schema);\n                delete schemaWithoutEncrypted.encrypted;\n                if (schemaWithoutEncrypted.attachments) {\n                    schemaWithoutEncrypted.attachments.encrypted = false;\n                }\n\n                const instance = await args.storage.createStorageInstance(\n                    Object.assign(\n                        {},\n                        params,\n                        {\n                            schema: schemaWithoutEncrypted\n                        }\n                    )\n                );\n\n                function modifyToStorage(docData: RxDocumentWriteData<RxDocType>) {\n                    docData = cloneWithoutAttachments(docData);\n                    ensureNotFalsy(params.schema.encrypted)\n                        .forEach(path => {\n                            const value = getProperty(docData, path);\n                            if (typeof value === 'undefined') {\n                                return;\n                            }\n\n                            const stringValue = JSON.stringify(value);\n                            const encrypted = encryptString(stringValue, password);\n                            setProperty(docData, path, encrypted);\n                        });\n\n                    // handle attachments\n                    if (\n                        params.schema.attachments &&\n                        params.schema.attachments.encrypted\n                    ) {\n                        const newAttachments: typeof docData._attachments = {};\n                        Object.entries(docData._attachments).forEach(([id, attachment]) => {\n                            const useAttachment: RxAttachmentWriteData = flatClone(attachment) as any;\n                            if (useAttachment.data) {\n                                const dataString = useAttachment.data;\n                                useAttachment.data = b64EncodeUnicode(encryptString(dataString, password));\n                            }\n                            newAttachments[id] = useAttachment;\n                        });\n                        docData._attachments = newAttachments;\n                    }\n                    return docData;\n                }\n                function modifyFromStorage(docData: RxDocumentData<any>): Promise<RxDocumentData<RxDocType>> {\n                    docData = cloneWithoutAttachments(docData);\n                    ensureNotFalsy(params.schema.encrypted)\n                        .forEach(path => {\n                            const value = getProperty(docData, path);\n                            if (typeof value === 'undefined') {\n                                return;\n                            }\n                            const decrypted = decryptString(value, password);\n                            const decryptedParsed = JSON.parse(decrypted);\n                            setProperty(docData, path, decryptedParsed);\n                        });\n                    return docData;\n                }\n\n                function modifyAttachmentFromStorage(attachmentData: string): string {\n                    if (\n                        params.schema.attachments &&\n                        params.schema.attachments.encrypted\n                    ) {\n                        const decrypted = decryptString(b64DecodeUnicode(attachmentData), password);\n                        return decrypted;\n                    } else {\n                        return attachmentData;\n                    }\n                }\n\n                return wrapRxStorageInstance(\n                    instance,\n                    modifyToStorage,\n                    modifyFromStorage,\n                    modifyAttachmentFromStorage\n                );\n            }\n        }\n    );\n}\n\n\n\n\n\nfunction cloneWithoutAttachments<T>(data: RxDocumentWriteData<T>): RxDocumentData<T> {\n    const attachments = data._attachments;\n    data = flatClone(data);\n    delete (data as any)._attachments;\n    data = clone(data);\n    data._attachments = attachments;\n    return data as any;\n}\n\nfunction validatePassword(password: string) {\n    if (typeof password !== 'string') {\n        throw newRxTypeError('EN1', {\n            password\n        });\n    }\n    if (password.length < MINIMUM_PASSWORD_LENGTH) {\n        throw newRxError('EN2', {\n            minPassLength: MINIMUM_PASSWORD_LENGTH,\n            password\n        });\n    }\n}\n"],"mappings":"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"}
\ No newline at end of file
diff --git a/node_modules/rxdb/dist/lib/plugins/replication-firestore/firestore-helper.js b/node_modules/rxdb/dist/lib/plugins/replication-firestore/firestore-helper.js
deleted file mode 100644
index 0270d61..0000000
--- a/node_modules/rxdb/dist/lib/plugins/replication-firestore/firestore-helper.js
+++ /dev/null
@@ -1,61 +0,0 @@
-"use strict";
-
-Object.defineProperty(exports, "__esModule", {
-  value: true
-});
-exports.FIRESTORE_REPLICATION_PLUGIN_IDENTITY_PREFIX = void 0;
-exports.firestoreRowToDocData = firestoreRowToDocData;
-exports.getContentByIds = getContentByIds;
-exports.getFirestoreSortFieldValue = getFirestoreSortFieldValue;
-exports.isoStringToServerTimestamp = isoStringToServerTimestamp;
-exports.serverTimestampToIsoString = serverTimestampToIsoString;
-exports.stripPrimaryKey = stripPrimaryKey;
-exports.stripServerTimestampField = stripServerTimestampField;
-var _firestore = require("firebase/firestore");
-var _utils = require("../../plugins/utils");
-var FIRESTORE_REPLICATION_PLUGIN_IDENTITY_PREFIX = 'firestore';
-exports.FIRESTORE_REPLICATION_PLUGIN_IDENTITY_PREFIX = FIRESTORE_REPLICATION_PLUGIN_IDENTITY_PREFIX;
-function getFirestoreSortFieldValue(docData, primaryKey) {
-  var timeString = (0, _utils.now)() + '';
-  return 'rxdb-' + timeString.padStart(15, '0') + '-' + docData[primaryKey];
-}
-function stripServerTimestampField(serverTimestampField, docData) {
-  var data = (0, _utils.flatClone)(docData);
-  delete data[serverTimestampField];
-  return data;
-}
-function serverTimestampToIsoString(serverTimestampField, docData) {
-  var timestamp = docData[serverTimestampField];
-  var date = timestamp.toDate();
-  return date.toISOString();
-}
-function isoStringToServerTimestamp(isoString) {
-  var date = new Date(isoString);
-  return _firestore.Timestamp.fromDate(date);
-}
-function firestoreRowToDocData(serverTimestampField, primaryPath, row) {
-  var docData = stripServerTimestampField(serverTimestampField, row.data());
-  docData[primaryPath] = row.id;
-  return docData;
-}
-function stripPrimaryKey(primaryPath, docData) {
-  docData = (0, _utils.flatClone)(docData);
-  delete docData[primaryPath];
-  return docData;
-}
-
-// https://stackoverflow.com/questions/61354866/is-there-a-workaround-for-the-firebase-query-in-limit-to-10
-function getContentByIds(ids, getQuery) {
-  var batches = [];
-  while (ids.length) {
-    // firestore limits batches to 10
-    var batch = ids.splice(0, 10);
-
-    // add the batch request to to a queue
-    batches.push(getQuery(batch));
-  }
-
-  // after all of the data is fetched, return it
-  return Promise.all(batches).then(content => content.map(i => i.docs).flat());
-}
-//# sourceMappingURL=firestore-helper.js.map
\ No newline at end of file
diff --git a/node_modules/rxdb/dist/lib/plugins/replication-firestore/firestore-helper.js.map b/node_modules/rxdb/dist/lib/plugins/replication-firestore/firestore-helper.js.map
deleted file mode 100644
index 4fa868b..0000000
--- a/node_modules/rxdb/dist/lib/plugins/replication-firestore/firestore-helper.js.map
+++ /dev/null
@@ -1 +0,0 @@
-{"version":3,"file":"firestore-helper.js","names":["_firestore","require","_utils","FIRESTORE_REPLICATION_PLUGIN_IDENTITY_PREFIX","exports","getFirestoreSortFieldValue","docData","primaryKey","timeString","now","padStart","stripServerTimestampField","serverTimestampField","data","flatClone","serverTimestampToIsoString","timestamp","date","toDate","toISOString","isoStringToServerTimestamp","isoString","Date","Timestamp","fromDate","firestoreRowToDocData","primaryPath","row","id","stripPrimaryKey","getContentByIds","ids","getQuery","batches","length","batch","splice","push","Promise","all","then","content","map","i","docs","flat"],"sources":["../../../../src/plugins/replication-firestore/firestore-helper.ts"],"sourcesContent":["import {\n    QueryDocumentSnapshot,\n    Timestamp\n} from 'firebase/firestore';\nimport type {\n    WithDeleted\n} from '../../types';\nimport { flatClone, now } from '../../plugins/utils';\nimport type { GetQuery } from './firestore-types';\n\nexport const FIRESTORE_REPLICATION_PLUGIN_IDENTITY_PREFIX = 'firestore';\n\n\nexport function getFirestoreSortFieldValue(docData: any, primaryKey: string): string {\n    const timeString = now() + '';\n    return 'rxdb-' + timeString.padStart(15, '0') + '-' + docData[primaryKey];\n}\n\nexport function stripServerTimestampField<RxDocType>(\n    serverTimestampField: string,\n    docData: RxDocType\n): WithDeleted<RxDocType> {\n    const data = flatClone(docData);\n    delete (data as any)[serverTimestampField];\n    return data as any;\n}\n\n\nexport function serverTimestampToIsoString(serverTimestampField: string, docData: any): string {\n    const timestamp = (docData as any)[serverTimestampField];\n    const date: Date = timestamp.toDate();\n    return date.toISOString();\n}\n\nexport function isoStringToServerTimestamp(isoString: string): Timestamp {\n    const date = new Date(isoString);\n    return Timestamp.fromDate(date);\n}\n\nexport function firestoreRowToDocData<RxDocType>(\n    serverTimestampField: string,\n    primaryPath: string,\n    row: QueryDocumentSnapshot<RxDocType>\n): WithDeleted<RxDocType> {\n    const docData = stripServerTimestampField(\n        serverTimestampField,\n        row.data()\n    );\n    (docData as any)[primaryPath] = row.id;\n    return docData;\n}\n\nexport function stripPrimaryKey(\n    primaryPath: string,\n    docData: any\n): any {\n    docData = flatClone(docData);\n    delete (docData as any)[primaryPath];\n    return docData;\n}\n\n// https://stackoverflow.com/questions/61354866/is-there-a-workaround-for-the-firebase-query-in-limit-to-10\nexport function getContentByIds<RxDocType>(ids: string[], getQuery: GetQuery<RxDocType>): Promise<QueryDocumentSnapshot<RxDocType>[]> {\n    const batches = [];\n\n    while (ids.length) {\n        // firestore limits batches to 10\n        const batch = ids.splice(0, 10);\n\n        // add the batch request to to a queue\n        batches.push(getQuery(batch));\n    }\n\n    // after all of the data is fetched, return it\n    return Promise.all(batches).then((content) => content.map(i => i.docs).flat());\n}\n"],"mappings":";;;;;;;;;;;;;AAAA,IAAAA,UAAA,GAAAC,OAAA;AAOA,IAAAC,MAAA,GAAAD,OAAA;AAGO,IAAME,4CAA4C,GAAG,WAAW;AAACC,OAAA,CAAAD,4CAAA,GAAAA,4CAAA;AAGjE,SAASE,0BAA0BA,CAACC,OAAY,EAAEC,UAAkB,EAAU;EACjF,IAAMC,UAAU,GAAG,IAAAC,UAAG,EAAC,CAAC,GAAG,EAAE;EAC7B,OAAO,OAAO,GAAGD,UAAU,CAACE,QAAQ,CAAC,EAAE,EAAE,GAAG,CAAC,GAAG,GAAG,GAAGJ,OAAO,CAACC,UAAU,CAAC;AAC7E;AAEO,SAASI,yBAAyBA,CACrCC,oBAA4B,EAC5BN,OAAkB,EACI;EACtB,IAAMO,IAAI,GAAG,IAAAC,gBAAS,EAACR,OAAO,CAAC;EAC/B,OAAQO,IAAI,CAASD,oBAAoB,CAAC;EAC1C,OAAOC,IAAI;AACf;AAGO,SAASE,0BAA0BA,CAACH,oBAA4B,EAAEN,OAAY,EAAU;EAC3F,IAAMU,SAAS,GAAIV,OAAO,CAASM,oBAAoB,CAAC;EACxD,IAAMK,IAAU,GAAGD,SAAS,CAACE,MAAM,CAAC,CAAC;EACrC,OAAOD,IAAI,CAACE,WAAW,CAAC,CAAC;AAC7B;AAEO,SAASC,0BAA0BA,CAACC,SAAiB,EAAa;EACrE,IAAMJ,IAAI,GAAG,IAAIK,IAAI,CAACD,SAAS,CAAC;EAChC,OAAOE,oBAAS,CAACC,QAAQ,CAACP,IAAI,CAAC;AACnC;AAEO,SAASQ,qBAAqBA,CACjCb,oBAA4B,EAC5Bc,WAAmB,EACnBC,GAAqC,EACf;EACtB,IAAMrB,OAAO,GAAGK,yBAAyB,CACrCC,oBAAoB,EACpBe,GAAG,CAACd,IAAI,CAAC,CACb,CAAC;EACAP,OAAO,CAASoB,WAAW,CAAC,GAAGC,GAAG,CAACC,EAAE;EACtC,OAAOtB,OAAO;AAClB;AAEO,SAASuB,eAAeA,CAC3BH,WAAmB,EACnBpB,OAAY,EACT;EACHA,OAAO,GAAG,IAAAQ,gBAAS,EAACR,OAAO,CAAC;EAC5B,OAAQA,OAAO,CAASoB,WAAW,CAAC;EACpC,OAAOpB,OAAO;AAClB;;AAEA;AACO,SAASwB,eAAeA,CAAYC,GAAa,EAAEC,QAA6B,EAA+C;EAClI,IAAMC,OAAO,GAAG,EAAE;EAElB,OAAOF,GAAG,CAACG,MAAM,EAAE;IACf;IACA,IAAMC,KAAK,GAAGJ,GAAG,CAACK,MAAM,CAAC,CAAC,EAAE,EAAE,CAAC;;IAE/B;IACAH,OAAO,CAACI,IAAI,CAACL,QAAQ,CAACG,KAAK,CAAC,CAAC;EACjC;;EAEA;EACA,OAAOG,OAAO,CAACC,GAAG,CAACN,OAAO,CAAC,CAACO,IAAI,CAAEC,OAAO,IAAKA,OAAO,CAACC,GAAG,CAACC,CAAC,IAAIA,CAAC,CAACC,IAAI,CAAC,CAACC,IAAI,CAAC,CAAC,CAAC;AAClF"}
\ No newline at end of file
diff --git a/node_modules/rxdb/dist/lib/plugins/replication-firestore/firestore-types.js b/node_modules/rxdb/dist/lib/plugins/replication-firestore/firestore-types.js
deleted file mode 100644
index 74386df..0000000
--- a/node_modules/rxdb/dist/lib/plugins/replication-firestore/firestore-types.js
+++ /dev/null
@@ -1,2 +0,0 @@
-"use strict";
-//# sourceMappingURL=firestore-types.js.map
\ No newline at end of file
diff --git a/node_modules/rxdb/dist/lib/plugins/replication-firestore/firestore-types.js.map b/node_modules/rxdb/dist/lib/plugins/replication-firestore/firestore-types.js.map
deleted file mode 100644
index 1bd05e8..0000000
--- a/node_modules/rxdb/dist/lib/plugins/replication-firestore/firestore-types.js.map
+++ /dev/null
@@ -1 +0,0 @@
-{"version":3,"file":"firestore-types.js","names":[],"sources":["../../../../src/plugins/replication-firestore/firestore-types.ts"],"sourcesContent":["import type {\n    MaybePromise,\n    ReplicationOptions,\n    ReplicationPullOptions,\n    ReplicationPushOptions,\n    WithDeleted\n} from '../../types';\n\nimport type {\n    CollectionReference,\n    Firestore,\n    QueryFieldFilterConstraint,\n    QuerySnapshot\n} from 'firebase/firestore';\n\nexport type FirestoreCheckpointType = {\n    id: string;\n    /**\n     * Firestore internally sets the time to an object like\n     * {\n     *       \"seconds\": 1669807105,\n     *       \"nanoseconds\": 476000000\n     * }\n     * But to be able to query that, we have to use a date string\n     * like '2022-11-30T11:18:25.141Z'\n     * so we store that string instead.\n     */\n    serverTimestamp: string;\n};\nexport type FirestoreCollection<RxDocType> = CollectionReference<RxDocType>;\n\nexport type FirestoreOptions<RxDocType> = {\n    projectId: string;\n    collection: FirestoreCollection<RxDocType>;\n    database: Firestore;\n};\n\nexport type FirestoreSyncPullOptions<RxDocType> =\n    Omit<ReplicationPullOptions<RxDocType, FirestoreCheckpointType>, 'handler' | 'stream$'>\n    & {\n        filter?: QueryFieldFilterConstraint | QueryFieldFilterConstraint[];\n    };\n\nexport type FirestoreSyncPushOptions<RxDocType> = Omit<ReplicationPushOptions<RxDocType>, 'handler'>\n    & {\n        filter?(item: WithDeleted<RxDocType>): MaybePromise<boolean>;\n    };\n\nexport type SyncOptionsFirestore<RxDocType> = Omit<\n    ReplicationOptions<RxDocType, any>,\n    'pull' | 'push' | 'replicationIdentifier'\n> & {\n    firestore: FirestoreOptions<RxDocType>;\n    /**\n     * In firestore it is not possible to read out\n     * the internally used write timestamp.\n     * Even if we could read it out, it is not indexed which\n     * is required for fetch 'changes-since-x'.\n     * So instead we have to rely on a custom user defined field\n     * that contains the server time which is set by firestore via serverTimestamp()\n     * IMPORTANT: The serverTimestampField MUST NOT be part of the collections RxJsonSchema!\n     * [default='serverTimestamp']\n     * @link https://groups.google.com/g/firebase-talk/c/tAmPzPei-mE\n     */\n    serverTimestampField?: string;\n    pull?: FirestoreSyncPullOptions<RxDocType>;\n    push?: FirestoreSyncPushOptions<RxDocType>;\n};\n\nexport type GetQuery<RxDocType> = (ids: string[]) => Promise<QuerySnapshot<RxDocType>>;\n"],"mappings":""}
\ No newline at end of file
diff --git a/node_modules/rxdb/dist/lib/plugins/replication-firestore/index.js b/node_modules/rxdb/dist/lib/plugins/replication-firestore/index.js
deleted file mode 100644
index 352b6cc..0000000
--- a/node_modules/rxdb/dist/lib/plugins/replication-firestore/index.js
+++ /dev/null
@@ -1,262 +0,0 @@
-"use strict";
-
-var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
-Object.defineProperty(exports, "__esModule", {
-  value: true
-});
-var _exportNames = {
-  RxFirestoreReplicationState: true,
-  replicateFirestore: true
-};
-exports.RxFirestoreReplicationState = void 0;
-exports.replicateFirestore = replicateFirestore;
-var _inheritsLoose2 = _interopRequireDefault(require("@babel/runtime/helpers/inheritsLoose"));
-var _utils = require("../../plugins/utils");
-var _firestore = require("firebase/firestore");
-var _leaderElection = require("../leader-election");
-var _replication = require("../replication");
-var _ = require("../../");
-var _rxjs = require("rxjs");
-var _firestoreHelper = require("./firestore-helper");
-Object.keys(_firestoreHelper).forEach(function (key) {
-  if (key === "default" || key === "__esModule") return;
-  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
-  if (key in exports && exports[key] === _firestoreHelper[key]) return;
-  Object.defineProperty(exports, key, {
-    enumerable: true,
-    get: function () {
-      return _firestoreHelper[key];
-    }
-  });
-});
-var _firestoreTypes = require("./firestore-types");
-Object.keys(_firestoreTypes).forEach(function (key) {
-  if (key === "default" || key === "__esModule") return;
-  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
-  if (key in exports && exports[key] === _firestoreTypes[key]) return;
-  Object.defineProperty(exports, key, {
-    enumerable: true,
-    get: function () {
-      return _firestoreTypes[key];
-    }
-  });
-});
-var RxFirestoreReplicationState = /*#__PURE__*/function (_RxReplicationState) {
-  (0, _inheritsLoose2.default)(RxFirestoreReplicationState, _RxReplicationState);
-  function RxFirestoreReplicationState(firestore, replicationIdentifierHash, collection, pull, push, live = true, retryTime = 1000 * 5, autoStart = true) {
-    var _this;
-    _this = _RxReplicationState.call(this, replicationIdentifierHash, collection, '_deleted', pull, push, live, retryTime, autoStart) || this;
-    _this.firestore = firestore;
-    _this.replicationIdentifierHash = replicationIdentifierHash;
-    _this.collection = collection;
-    _this.pull = pull;
-    _this.push = push;
-    _this.live = live;
-    _this.retryTime = retryTime;
-    _this.autoStart = autoStart;
-    return _this;
-  }
-  return RxFirestoreReplicationState;
-}(_replication.RxReplicationState);
-exports.RxFirestoreReplicationState = RxFirestoreReplicationState;
-function replicateFirestore(options) {
-  var collection = options.collection;
-  (0, _.addRxPlugin)(_leaderElection.RxDBLeaderElectionPlugin);
-  var pullStream$ = new _rxjs.Subject();
-  var replicationPrimitivesPull;
-  options.live = typeof options.live === 'undefined' ? true : options.live;
-  options.waitForLeadership = typeof options.waitForLeadership === 'undefined' ? true : options.waitForLeadership;
-  var serverTimestampField = typeof options.serverTimestampField === 'undefined' ? 'serverTimestamp' : options.serverTimestampField;
-  options.serverTimestampField = serverTimestampField;
-  var primaryPath = collection.schema.primaryPath;
-
-  /**
-   * The serverTimestampField MUST NOT be part of the collections RxJsonSchema.
-   */
-  var schemaPart = (0, _.getSchemaByObjectPath)(collection.schema.jsonSchema, serverTimestampField);
-  if (schemaPart ||
-  // also must not be nested.
-  serverTimestampField.includes('.')) {
-    throw (0, _.newRxError)('RC6', {
-      field: serverTimestampField,
-      schema: collection.schema.jsonSchema
-    });
-  }
-  var pullFilters = options.pull?.filter !== undefined ? (0, _utils.toArray)(options.pull.filter) : [];
-  var pullQuery = (0, _firestore.query)(options.firestore.collection, ...pullFilters);
-  if (options.pull) {
-    replicationPrimitivesPull = {
-      async handler(lastPulledCheckpoint, batchSize) {
-        var newerQuery;
-        var sameTimeQuery;
-        if (lastPulledCheckpoint) {
-          var lastServerTimestamp = (0, _firestoreHelper.isoStringToServerTimestamp)(lastPulledCheckpoint.serverTimestamp);
-          newerQuery = (0, _firestore.query)(pullQuery, (0, _firestore.where)(serverTimestampField, '>', lastServerTimestamp), (0, _firestore.orderBy)(serverTimestampField, 'asc'), (0, _firestore.limit)(batchSize));
-          sameTimeQuery = (0, _firestore.query)(pullQuery, (0, _firestore.where)(serverTimestampField, '==', lastServerTimestamp), (0, _firestore.where)(primaryPath, '>', lastPulledCheckpoint.id), (0, _firestore.orderBy)(primaryPath, 'asc'), (0, _firestore.limit)(batchSize));
-        } else {
-          newerQuery = (0, _firestore.query)(pullQuery, (0, _firestore.orderBy)(serverTimestampField, 'asc'), (0, _firestore.limit)(batchSize));
-        }
-        var mustsReRun = true;
-        var useDocs = [];
-        while (mustsReRun) {
-          /**
-           * Local writes that have not been persisted to the server
-           * are in pending state and do not have a correct serverTimestamp set.
-           * We have to ensure we only use document states that are in sync with the server.
-           * @link https://medium.com/firebase-developers/the-secrets-of-firestore-fieldvalue-servertimestamp-revealed-29dd7a38a82b
-           */
-          await (0, _firestore.waitForPendingWrites)(options.firestore.database);
-          await (0, _firestore.runTransaction)(options.firestore.database, async _tx => {
-            useDocs = [];
-            var [newerQueryResult, sameTimeQueryResult] = await Promise.all([(0, _firestore.getDocs)(newerQuery), sameTimeQuery ? (0, _firestore.getDocs)(sameTimeQuery) : undefined]);
-            if (newerQueryResult.metadata.hasPendingWrites || sameTimeQuery && (0, _utils.ensureNotFalsy)(sameTimeQueryResult).metadata.hasPendingWrites) {
-              return;
-            } else {
-              mustsReRun = false;
-              if (sameTimeQuery) {
-                useDocs = (0, _utils.ensureNotFalsy)(sameTimeQueryResult).docs;
-              }
-              var missingAmount = batchSize - useDocs.length;
-              if (missingAmount > 0) {
-                var additionalDocs = newerQueryResult.docs.slice(0, missingAmount).filter(x => !!x);
-                (0, _utils.appendToArray)(useDocs, additionalDocs);
-              }
-            }
-          });
-        }
-        if (useDocs.length === 0) {
-          return {
-            checkpoint: lastPulledCheckpoint,
-            documents: []
-          };
-        }
-        var lastDoc = (0, _utils.ensureNotFalsy)((0, _utils.lastOfArray)(useDocs));
-        var documents = useDocs.map(row => (0, _firestoreHelper.firestoreRowToDocData)(serverTimestampField, primaryPath, row));
-        var newCheckpoint = {
-          id: lastDoc.id,
-          serverTimestamp: (0, _firestoreHelper.serverTimestampToIsoString)(serverTimestampField, lastDoc.data())
-        };
-        var ret = {
-          documents: documents,
-          checkpoint: newCheckpoint
-        };
-        return ret;
-      },
-      batchSize: (0, _utils.ensureNotFalsy)(options.pull).batchSize,
-      modifier: (0, _utils.ensureNotFalsy)(options.pull).modifier,
-      stream$: pullStream$.asObservable()
-    };
-  }
-  var replicationPrimitivesPush;
-  if (options.push) {
-    var pushFilter = options.push?.filter;
-    replicationPrimitivesPush = {
-      async handler(rows) {
-        if (pushFilter !== undefined) {
-          rows = await (0, _utils.asyncFilter)(rows, row => pushFilter(row.newDocumentState));
-        }
-        var writeRowsById = {};
-        var docIds = rows.map(row => {
-          var docId = row.newDocumentState[primaryPath];
-          writeRowsById[docId] = row;
-          return docId;
-        });
-        await (0, _firestore.waitForPendingWrites)(options.firestore.database);
-        var conflicts = [];
-
-        /**
-         * Everything must run INSIDE of the transaction
-         * because on tx-errors, firebase will re-run the transaction on some cases.
-         * @link https://firebase.google.com/docs/firestore/manage-data/transactions#transaction_failure
-         * @link https://firebase.google.com/docs/firestore/manage-data/transactions
-         */
-        await (0, _firestore.runTransaction)(options.firestore.database, async _tx => {
-          conflicts = []; // reset in case the tx has re-run.
-          /**
-           * @link https://stackoverflow.com/a/48423626/3443137
-           */
-
-          var getQuery = ids => {
-            return (0, _firestore.getDocs)((0, _firestore.query)(options.firestore.collection, (0, _firestore.where)((0, _firestore.documentId)(), 'in', ids)));
-          };
-          var docsInDbResult = await (0, _firestoreHelper.getContentByIds)(docIds, getQuery);
-          var docsInDbById = {};
-          docsInDbResult.forEach(row => {
-            var docDataInDb = (0, _firestoreHelper.stripServerTimestampField)(serverTimestampField, row.data());
-            var docId = row.id;
-            docDataInDb[primaryPath] = docId;
-            docsInDbById[docId] = docDataInDb;
-          });
-
-          /**
-           * @link https://firebase.google.com/docs/firestore/manage-data/transactions#batched-writes
-           */
-          var batch = (0, _firestore.writeBatch)(options.firestore.database);
-          var hasWrite = false;
-          await Promise.all(Object.entries(writeRowsById).map(async ([docId, writeRow]) => {
-            var docInDb = docsInDbById[docId];
-            if (docInDb && (!writeRow.assumedMasterState || (await collection.conflictHandler({
-              newDocumentState: docInDb,
-              realMasterState: writeRow.assumedMasterState
-            }, 'replication-firestore-push')).isEqual === false)) {
-              // conflict
-              conflicts.push(docInDb);
-            } else {
-              // no conflict
-              hasWrite = true;
-              var docRef = (0, _firestore.doc)(options.firestore.collection, docId);
-              var writeDocData = (0, _utils.flatClone)(writeRow.newDocumentState);
-              writeDocData[serverTimestampField] = (0, _firestore.serverTimestamp)();
-              if (!docInDb) {
-                // insert
-                batch.set(docRef, (0, _firestoreHelper.stripPrimaryKey)(primaryPath, writeDocData));
-              } else {
-                // update
-                batch.update(docRef, (0, _firestoreHelper.stripPrimaryKey)(primaryPath, writeDocData));
-              }
-            }
-          }));
-          if (hasWrite) {
-            await batch.commit();
-          }
-        });
-        await (0, _firestore.waitForPendingWrites)(options.firestore.database);
-        return conflicts;
-      },
-      batchSize: options.push.batchSize,
-      modifier: options.push.modifier
-    };
-  }
-  var replicationState = new RxFirestoreReplicationState(options.firestore, _firestoreHelper.FIRESTORE_REPLICATION_PLUGIN_IDENTITY_PREFIX + options.collection.database.hashFunction(options.firestore.projectId), collection, replicationPrimitivesPull, replicationPrimitivesPush, options.live, options.retryTime, options.autoStart);
-
-  /**
-   * Use long polling to get live changes for the pull.stream$
-   */
-  if (options.live && options.pull) {
-    var startBefore = replicationState.start.bind(replicationState);
-    var cancelBefore = replicationState.cancel.bind(replicationState);
-    replicationState.start = () => {
-      var lastChangeQuery = (0, _firestore.query)(pullQuery, (0, _firestore.orderBy)(serverTimestampField, 'desc'), (0, _firestore.limit)(1));
-      var unsubscribe = (0, _firestore.onSnapshot)(lastChangeQuery, _querySnapshot => {
-        /**
-         * There is no good way to observe the event stream in firestore.
-         * So instead we listen to any write to the collection
-         * and then emit a 'RESYNC' flag.
-         */
-        replicationState.reSync();
-      }, error => {
-        replicationState.subjects.error.next((0, _.newRxError)('RC_STREAM', {
-          error: (0, _utils.errorToPlainJson)(error)
-        }));
-      });
-      replicationState.cancel = () => {
-        unsubscribe();
-        return cancelBefore();
-      };
-      return startBefore();
-    };
-  }
-  (0, _replication.startReplicationOnLeaderShip)(options.waitForLeadership, replicationState);
-  return replicationState;
-}
-//# sourceMappingURL=index.js.map
\ No newline at end of file
diff --git a/node_modules/rxdb/dist/lib/plugins/replication-firestore/index.js.map b/node_modules/rxdb/dist/lib/plugins/replication-firestore/index.js.map
deleted file mode 100644
index 65dd52d..0000000
--- a/node_modules/rxdb/dist/lib/plugins/replication-firestore/index.js.map
+++ /dev/null
@@ -1 +0,0 @@
-{"version":3,"file":"index.js","names":["_utils","require","_firestore","_leaderElection","_replication","_","_rxjs","_firestoreHelper","Object","keys","forEach","key","prototype","hasOwnProperty","call","_exportNames","exports","defineProperty","enumerable","get","_firestoreTypes","RxFirestoreReplicationState","_RxReplicationState","_inheritsLoose2","default","firestore","replicationIdentifierHash","collection","pull","push","live","retryTime","autoStart","_this","RxReplicationState","replicateFirestore","options","addRxPlugin","RxDBLeaderElectionPlugin","pullStream$","Subject","replicationPrimitivesPull","waitForLeadership","serverTimestampField","primaryPath","schema","schemaPart","getSchemaByObjectPath","jsonSchema","includes","newRxError","field","pullFilters","filter","undefined","toArray","pullQuery","query","handler","lastPulledCheckpoint","batchSize","newerQuery","sameTimeQuery","lastServerTimestamp","isoStringToServerTimestamp","serverTimestamp","where","orderBy","limit","id","mustsReRun","useDocs","waitForPendingWrites","database","runTransaction","_tx","newerQueryResult","sameTimeQueryResult","Promise","all","getDocs","metadata","hasPendingWrites","ensureNotFalsy","docs","missingAmount","length","additionalDocs","slice","x","appendToArray","checkpoint","documents","lastDoc","lastOfArray","map","row","firestoreRowToDocData","newCheckpoint","serverTimestampToIsoString","data","ret","modifier","stream$","asObservable","replicationPrimitivesPush","pushFilter","rows","asyncFilter","newDocumentState","writeRowsById","docIds","docId","conflicts","getQuery","ids","documentId","docsInDbResult","getContentByIds","docsInDbById","docDataInDb","stripServerTimestampField","batch","writeBatch","hasWrite","entries","writeRow","docInDb","assumedMasterState","conflictHandler","realMasterState","isEqual","docRef","doc","writeDocData","flatClone","set","stripPrimaryKey","update","commit","replicationState","FIRESTORE_REPLICATION_PLUGIN_IDENTITY_PREFIX","hashFunction","projectId","startBefore","start","bind","cancelBefore","cancel","lastChangeQuery","unsubscribe","onSnapshot","_querySnapshot","reSync","error","subjects","next","errorToPlainJson","startReplicationOnLeaderShip"],"sources":["../../../../src/plugins/replication-firestore/index.ts"],"sourcesContent":["import {\n    appendToArray,\n    asyncFilter,\n    ensureNotFalsy,\n    errorToPlainJson,\n    flatClone,\n    lastOfArray,\n    toArray\n} from '../../plugins/utils';\n\nimport {\n    doc,\n    query,\n    where,\n    orderBy,\n    limit,\n    getDocs,\n    onSnapshot,\n    runTransaction,\n    writeBatch,\n    serverTimestamp,\n    QueryDocumentSnapshot,\n    waitForPendingWrites,\n    documentId\n} from 'firebase/firestore';\n\nimport { RxDBLeaderElectionPlugin } from '../leader-election';\nimport type {\n    RxCollection,\n    ReplicationPullOptions,\n    ReplicationPushOptions,\n    RxReplicationWriteToMasterRow,\n    RxReplicationPullStreamItem\n} from '../../types';\nimport {\n    RxReplicationState,\n    startReplicationOnLeaderShip\n} from '../replication';\nimport {\n    addRxPlugin,\n    ById,\n    getSchemaByObjectPath,\n    newRxError,\n    WithDeleted\n} from '../../';\n\nimport type {\n    FirestoreCheckpointType,\n    FirestoreOptions,\n    SyncOptionsFirestore\n} from './firestore-types';\nimport { Subject } from 'rxjs';\nimport {\n    firestoreRowToDocData,\n    FIRESTORE_REPLICATION_PLUGIN_IDENTITY_PREFIX,\n    getContentByIds,\n    isoStringToServerTimestamp,\n    serverTimestampToIsoString,\n    stripPrimaryKey,\n    stripServerTimestampField\n} from './firestore-helper';\n\nexport * from './firestore-helper';\nexport * from './firestore-types';\n\nexport class RxFirestoreReplicationState<RxDocType> extends RxReplicationState<RxDocType, FirestoreCheckpointType> {\n    constructor(\n        public readonly firestore: FirestoreOptions<RxDocType>,\n        public readonly replicationIdentifierHash: string,\n        public readonly collection: RxCollection<RxDocType>,\n        public readonly pull?: ReplicationPullOptions<RxDocType, FirestoreCheckpointType>,\n        public readonly push?: ReplicationPushOptions<RxDocType>,\n        public readonly live: boolean = true,\n        public retryTime: number = 1000 * 5,\n        public autoStart: boolean = true\n    ) {\n        super(\n            replicationIdentifierHash,\n            collection,\n            '_deleted',\n            pull,\n            push,\n            live,\n            retryTime,\n            autoStart\n        );\n    }\n}\n\nexport function replicateFirestore<RxDocType>(\n    options: SyncOptionsFirestore<RxDocType>\n): RxFirestoreReplicationState<RxDocType> {\n    const collection = options.collection;\n    addRxPlugin(RxDBLeaderElectionPlugin);\n    const pullStream$: Subject<RxReplicationPullStreamItem<RxDocType, FirestoreCheckpointType>> = new Subject();\n    let replicationPrimitivesPull: ReplicationPullOptions<RxDocType, FirestoreCheckpointType> | undefined;\n    options.live = typeof options.live === 'undefined' ? true : options.live;\n    options.waitForLeadership = typeof options.waitForLeadership === 'undefined' ? true : options.waitForLeadership;\n    const serverTimestampField = typeof options.serverTimestampField === 'undefined' ? 'serverTimestamp' : options.serverTimestampField;\n    options.serverTimestampField = serverTimestampField;\n    const primaryPath = collection.schema.primaryPath;\n\n    /**\n     * The serverTimestampField MUST NOT be part of the collections RxJsonSchema.\n     */\n    const schemaPart = getSchemaByObjectPath(collection.schema.jsonSchema, serverTimestampField);\n    if (\n        schemaPart ||\n        // also must not be nested.\n        serverTimestampField.includes('.')\n    ) {\n        throw newRxError('RC6', {\n            field: serverTimestampField,\n            schema: collection.schema.jsonSchema\n        });\n    }\n\n    const pullFilters = options.pull?.filter !== undefined\n        ? toArray(options.pull.filter)\n        : [];\n\n    const pullQuery = query(options.firestore.collection, ...pullFilters);\n\n    if (options.pull) {\n        replicationPrimitivesPull = {\n            async handler(\n                lastPulledCheckpoint: FirestoreCheckpointType,\n                batchSize: number\n            ) {\n                let newerQuery: ReturnType<typeof query>;\n                let sameTimeQuery: ReturnType<typeof query> | undefined;\n\n                if (lastPulledCheckpoint) {\n                    const lastServerTimestamp = isoStringToServerTimestamp(lastPulledCheckpoint.serverTimestamp);\n                    newerQuery = query(pullQuery,\n                        where(serverTimestampField, '>', lastServerTimestamp),\n                        orderBy(serverTimestampField, 'asc'),\n                        limit(batchSize)\n                    );\n                    sameTimeQuery = query(pullQuery,\n                        where(serverTimestampField, '==', lastServerTimestamp),\n                        where(primaryPath, '>', lastPulledCheckpoint.id),\n                        orderBy(primaryPath, 'asc'),\n                        limit(batchSize)\n                    );\n                } else {\n                    newerQuery = query(pullQuery,\n                        orderBy(serverTimestampField, 'asc'),\n                        limit(batchSize)\n                    );\n                }\n\n                let mustsReRun = true;\n                let useDocs: QueryDocumentSnapshot<RxDocType>[] = [];\n                while (mustsReRun) {\n                    /**\n                     * Local writes that have not been persisted to the server\n                     * are in pending state and do not have a correct serverTimestamp set.\n                     * We have to ensure we only use document states that are in sync with the server.\n                     * @link https://medium.com/firebase-developers/the-secrets-of-firestore-fieldvalue-servertimestamp-revealed-29dd7a38a82b\n                     */\n                    await waitForPendingWrites(options.firestore.database);\n                    await runTransaction(options.firestore.database, async (_tx) => {\n                        useDocs = [];\n                        const [\n                            newerQueryResult,\n                            sameTimeQueryResult\n                        ] = await Promise.all([\n                            getDocs(newerQuery),\n                            sameTimeQuery ? getDocs(sameTimeQuery) : undefined\n                        ]);\n\n                        if (\n                            newerQueryResult.metadata.hasPendingWrites ||\n                            (sameTimeQuery && ensureNotFalsy(sameTimeQueryResult).metadata.hasPendingWrites)\n                        ) {\n                            return;\n                        } else {\n                            mustsReRun = false;\n\n                            if (sameTimeQuery) {\n                                useDocs = ensureNotFalsy(sameTimeQueryResult).docs as any;\n                            }\n                            const missingAmount = batchSize - useDocs.length;\n                            if (missingAmount > 0) {\n                                const additionalDocs = newerQueryResult.docs.slice(0, missingAmount).filter(x => !!x);\n                                appendToArray(useDocs, additionalDocs);\n                            }\n                        }\n                    });\n                }\n\n                if (useDocs.length === 0) {\n                    return {\n                        checkpoint: lastPulledCheckpoint,\n                        documents: []\n                    };\n                }\n                const lastDoc = ensureNotFalsy(lastOfArray(useDocs));\n                const documents: WithDeleted<RxDocType>[] = useDocs\n                    .map(row => firestoreRowToDocData(\n                        serverTimestampField,\n                        primaryPath,\n                        row\n                    ));\n                const newCheckpoint: FirestoreCheckpointType = {\n                    id: lastDoc.id,\n                    serverTimestamp: serverTimestampToIsoString(serverTimestampField, lastDoc.data())\n                };\n                const ret = {\n                    documents: documents,\n                    checkpoint: newCheckpoint\n                };\n                return ret;\n            },\n            batchSize: ensureNotFalsy(options.pull).batchSize,\n            modifier: ensureNotFalsy(options.pull).modifier,\n            stream$: pullStream$.asObservable()\n        };\n    }\n\n    let replicationPrimitivesPush: ReplicationPushOptions<RxDocType> | undefined;\n    if (options.push) {\n        const pushFilter = options.push?.filter;\n        replicationPrimitivesPush = {\n            async handler(\n                rows: RxReplicationWriteToMasterRow<RxDocType>[]\n            ) {\n                if (pushFilter !== undefined) {\n                    rows = await asyncFilter(rows, (row) => pushFilter(row.newDocumentState));\n                }\n\n                const writeRowsById: ById<RxReplicationWriteToMasterRow<RxDocType>> = {};\n                const docIds: string[] = rows.map(row => {\n                    const docId = (row.newDocumentState as any)[primaryPath];\n                    writeRowsById[docId] = row;\n                    return docId;\n                });\n                await waitForPendingWrites(options.firestore.database);\n                let conflicts: WithDeleted<RxDocType>[] = [];\n\n                /**\n                 * Everything must run INSIDE of the transaction\n                 * because on tx-errors, firebase will re-run the transaction on some cases.\n                 * @link https://firebase.google.com/docs/firestore/manage-data/transactions#transaction_failure\n                 * @link https://firebase.google.com/docs/firestore/manage-data/transactions\n                 */\n                await runTransaction(options.firestore.database, async (_tx) => {\n                    conflicts = []; // reset in case the tx has re-run.\n                    /**\n                     * @link https://stackoverflow.com/a/48423626/3443137\n                     */\n\n                    const getQuery = (ids: string[]) => {\n                        return getDocs(\n                            query(\n                                options.firestore.collection,\n                                where(documentId(), 'in', ids)\n                            )\n                        );\n                    };\n\n                    const docsInDbResult = await getContentByIds<RxDocType>(docIds, getQuery);\n\n                    const docsInDbById: ById<RxDocType> = {};\n                    docsInDbResult.forEach(row => {\n                        const docDataInDb = stripServerTimestampField(serverTimestampField, row.data());\n                        const docId = row.id;\n                        (docDataInDb as any)[primaryPath] = docId;\n                        docsInDbById[docId] = docDataInDb;\n                    });\n\n                    /**\n                     * @link https://firebase.google.com/docs/firestore/manage-data/transactions#batched-writes\n                     */\n                    const batch = writeBatch(options.firestore.database);\n                    let hasWrite = false;\n                    await Promise.all(\n                        Object.entries(writeRowsById).map(async ([docId, writeRow]) => {\n                            const docInDb: RxDocType | undefined = docsInDbById[docId];\n\n                            if (\n                                docInDb &&\n                                (\n                                    !writeRow.assumedMasterState ||\n                                    (await collection.conflictHandler({\n                                        newDocumentState: docInDb as any,\n                                        realMasterState: writeRow.assumedMasterState\n                                    }, 'replication-firestore-push')).isEqual === false\n                                )\n                            ) {\n                                // conflict\n                                conflicts.push(docInDb as any);\n                            } else {\n                                // no conflict\n                                hasWrite = true;\n                                const docRef = doc(options.firestore.collection, docId);\n                                const writeDocData = flatClone(writeRow.newDocumentState);\n                                (writeDocData as any)[serverTimestampField] = serverTimestamp();\n                                if (!docInDb) {\n                                    // insert\n                                    batch.set(docRef, stripPrimaryKey(primaryPath, writeDocData));\n                                } else {\n                                    // update\n                                    batch.update(docRef, stripPrimaryKey(primaryPath, writeDocData));\n                                }\n                            }\n                        })\n                    );\n\n                    if (hasWrite) {\n                        await batch.commit();\n                    }\n                });\n                await waitForPendingWrites(options.firestore.database);\n                return conflicts;\n            },\n            batchSize: options.push.batchSize,\n            modifier: options.push.modifier\n        };\n    }\n\n\n    const replicationState = new RxFirestoreReplicationState<RxDocType>(\n        options.firestore,\n        FIRESTORE_REPLICATION_PLUGIN_IDENTITY_PREFIX + options.collection.database.hashFunction(options.firestore.projectId),\n        collection,\n        replicationPrimitivesPull,\n        replicationPrimitivesPush,\n        options.live,\n        options.retryTime,\n        options.autoStart\n    );\n\n    /**\n     * Use long polling to get live changes for the pull.stream$\n     */\n    if (options.live && options.pull) {\n        const startBefore = replicationState.start.bind(replicationState);\n        const cancelBefore = replicationState.cancel.bind(replicationState);\n        replicationState.start = () => {\n            const lastChangeQuery = query(\n                pullQuery,\n                orderBy(serverTimestampField, 'desc'),\n                limit(1)\n            );\n            const unsubscribe = onSnapshot(\n                lastChangeQuery,\n                (_querySnapshot) => {\n                    /**\n                     * There is no good way to observe the event stream in firestore.\n                     * So instead we listen to any write to the collection\n                     * and then emit a 'RESYNC' flag.\n                     */\n                    replicationState.reSync();\n                },\n                (error) => {\n                    replicationState.subjects.error.next(\n                        newRxError('RC_STREAM', { error: errorToPlainJson(error) })\n                    );\n                }\n            );\n            replicationState.cancel = () => {\n                unsubscribe();\n                return cancelBefore();\n            };\n            return startBefore();\n        };\n    }\n\n    startReplicationOnLeaderShip(options.waitForLeadership, replicationState);\n\n    return replicationState;\n}\n"],"mappings":";;;;;;;;;;;;;AAAA,IAAAA,MAAA,GAAAC,OAAA;AAUA,IAAAC,UAAA,GAAAD,OAAA;AAgBA,IAAAE,eAAA,GAAAF,OAAA;AAQA,IAAAG,YAAA,GAAAH,OAAA;AAIA,IAAAI,CAAA,GAAAJ,OAAA;AAaA,IAAAK,KAAA,GAAAL,OAAA;AACA,IAAAM,gBAAA,GAAAN,OAAA;AAUAO,MAAA,CAAAC,IAAA,CAAAF,gBAAA,EAAAG,OAAA,WAAAC,GAAA;EAAA,IAAAA,GAAA,kBAAAA,GAAA;EAAA,IAAAH,MAAA,CAAAI,SAAA,CAAAC,cAAA,CAAAC,IAAA,CAAAC,YAAA,EAAAJ,GAAA;EAAA,IAAAA,GAAA,IAAAK,OAAA,IAAAA,OAAA,CAAAL,GAAA,MAAAJ,gBAAA,CAAAI,GAAA;EAAAH,MAAA,CAAAS,cAAA,CAAAD,OAAA,EAAAL,GAAA;IAAAO,UAAA;IAAAC,GAAA,WAAAA,CAAA;MAAA,OAAAZ,gBAAA,CAAAI,GAAA;IAAA;EAAA;AAAA;AACA,IAAAS,eAAA,GAAAnB,OAAA;AAAAO,MAAA,CAAAC,IAAA,CAAAW,eAAA,EAAAV,OAAA,WAAAC,GAAA;EAAA,IAAAA,GAAA,kBAAAA,GAAA;EAAA,IAAAH,MAAA,CAAAI,SAAA,CAAAC,cAAA,CAAAC,IAAA,CAAAC,YAAA,EAAAJ,GAAA;EAAA,IAAAA,GAAA,IAAAK,OAAA,IAAAA,OAAA,CAAAL,GAAA,MAAAS,eAAA,CAAAT,GAAA;EAAAH,MAAA,CAAAS,cAAA,CAAAD,OAAA,EAAAL,GAAA;IAAAO,UAAA;IAAAC,GAAA,WAAAA,CAAA;MAAA,OAAAC,eAAA,CAAAT,GAAA;IAAA;EAAA;AAAA;AAAkC,IAErBU,2BAA2B,0BAAAC,mBAAA;EAAA,IAAAC,eAAA,CAAAC,OAAA,EAAAH,2BAAA,EAAAC,mBAAA;EACpC,SAAAD,4BACoBI,SAAsC,EACtCC,yBAAiC,EACjCC,UAAmC,EACnCC,IAAiE,EACjEC,IAAwC,EACxCC,IAAa,GAAG,IAAI,EAC7BC,SAAiB,GAAG,IAAI,GAAG,CAAC,EAC5BC,SAAkB,GAAG,IAAI,EAClC;IAAA,IAAAC,KAAA;IACEA,KAAA,GAAAX,mBAAA,CAAAR,IAAA,OACIY,yBAAyB,EACzBC,UAAU,EACV,UAAU,EACVC,IAAI,EACJC,IAAI,EACJC,IAAI,EACJC,SAAS,EACTC,SACJ,CAAC;IAACC,KAAA,CAlBcR,SAAsC,GAAtCA,SAAsC;IAAAQ,KAAA,CACtCP,yBAAiC,GAAjCA,yBAAiC;IAAAO,KAAA,CACjCN,UAAmC,GAAnCA,UAAmC;IAAAM,KAAA,CACnCL,IAAiE,GAAjEA,IAAiE;IAAAK,KAAA,CACjEJ,IAAwC,GAAxCA,IAAwC;IAAAI,KAAA,CACxCH,IAAa,GAAbA,IAAa;IAAAG,KAAA,CACtBF,SAAiB,GAAjBA,SAAiB;IAAAE,KAAA,CACjBD,SAAkB,GAAlBA,SAAkB;IAAA,OAAAC,KAAA;EAY7B;EAAC,OAAAZ,2BAAA;AAAA,EArBuDa,+BAAkB;AAAAlB,OAAA,CAAAK,2BAAA,GAAAA,2BAAA;AAwBvE,SAASc,kBAAkBA,CAC9BC,OAAwC,EACF;EACtC,IAAMT,UAAU,GAAGS,OAAO,CAACT,UAAU;EACrC,IAAAU,aAAW,EAACC,wCAAwB,CAAC;EACrC,IAAMC,WAAqF,GAAG,IAAIC,aAAO,CAAC,CAAC;EAC3G,IAAIC,yBAAiG;EACrGL,OAAO,CAACN,IAAI,GAAG,OAAOM,OAAO,CAACN,IAAI,KAAK,WAAW,GAAG,IAAI,GAAGM,OAAO,CAACN,IAAI;EACxEM,OAAO,CAACM,iBAAiB,GAAG,OAAON,OAAO,CAACM,iBAAiB,KAAK,WAAW,GAAG,IAAI,GAAGN,OAAO,CAACM,iBAAiB;EAC/G,IAAMC,oBAAoB,GAAG,OAAOP,OAAO,CAACO,oBAAoB,KAAK,WAAW,GAAG,iBAAiB,GAAGP,OAAO,CAACO,oBAAoB;EACnIP,OAAO,CAACO,oBAAoB,GAAGA,oBAAoB;EACnD,IAAMC,WAAW,GAAGjB,UAAU,CAACkB,MAAM,CAACD,WAAW;;EAEjD;AACJ;AACA;EACI,IAAME,UAAU,GAAG,IAAAC,uBAAqB,EAACpB,UAAU,CAACkB,MAAM,CAACG,UAAU,EAAEL,oBAAoB,CAAC;EAC5F,IACIG,UAAU;EACV;EACAH,oBAAoB,CAACM,QAAQ,CAAC,GAAG,CAAC,EACpC;IACE,MAAM,IAAAC,YAAU,EAAC,KAAK,EAAE;MACpBC,KAAK,EAAER,oBAAoB;MAC3BE,MAAM,EAAElB,UAAU,CAACkB,MAAM,CAACG;IAC9B,CAAC,CAAC;EACN;EAEA,IAAMI,WAAW,GAAGhB,OAAO,CAACR,IAAI,EAAEyB,MAAM,KAAKC,SAAS,GAChD,IAAAC,cAAO,EAACnB,OAAO,CAACR,IAAI,CAACyB,MAAM,CAAC,GAC5B,EAAE;EAER,IAAMG,SAAS,GAAG,IAAAC,gBAAK,EAACrB,OAAO,CAACX,SAAS,CAACE,UAAU,EAAE,GAAGyB,WAAW,CAAC;EAErE,IAAIhB,OAAO,CAACR,IAAI,EAAE;IACda,yBAAyB,GAAG;MACxB,MAAMiB,OAAOA,CACTC,oBAA6C,EAC7CC,SAAiB,EACnB;QACE,IAAIC,UAAoC;QACxC,IAAIC,aAAmD;QAEvD,IAAIH,oBAAoB,EAAE;UACtB,IAAMI,mBAAmB,GAAG,IAAAC,2CAA0B,EAACL,oBAAoB,CAACM,eAAe,CAAC;UAC5FJ,UAAU,GAAG,IAAAJ,gBAAK,EAACD,SAAS,EACxB,IAAAU,gBAAK,EAACvB,oBAAoB,EAAE,GAAG,EAAEoB,mBAAmB,CAAC,EACrD,IAAAI,kBAAO,EAACxB,oBAAoB,EAAE,KAAK,CAAC,EACpC,IAAAyB,gBAAK,EAACR,SAAS,CACnB,CAAC;UACDE,aAAa,GAAG,IAAAL,gBAAK,EAACD,SAAS,EAC3B,IAAAU,gBAAK,EAACvB,oBAAoB,EAAE,IAAI,EAAEoB,mBAAmB,CAAC,EACtD,IAAAG,gBAAK,EAACtB,WAAW,EAAE,GAAG,EAAEe,oBAAoB,CAACU,EAAE,CAAC,EAChD,IAAAF,kBAAO,EAACvB,WAAW,EAAE,KAAK,CAAC,EAC3B,IAAAwB,gBAAK,EAACR,SAAS,CACnB,CAAC;QACL,CAAC,MAAM;UACHC,UAAU,GAAG,IAAAJ,gBAAK,EAACD,SAAS,EACxB,IAAAW,kBAAO,EAACxB,oBAAoB,EAAE,KAAK,CAAC,EACpC,IAAAyB,gBAAK,EAACR,SAAS,CACnB,CAAC;QACL;QAEA,IAAIU,UAAU,GAAG,IAAI;QACrB,IAAIC,OAA2C,GAAG,EAAE;QACpD,OAAOD,UAAU,EAAE;UACf;AACpB;AACA;AACA;AACA;AACA;UACoB,MAAM,IAAAE,+BAAoB,EAACpC,OAAO,CAACX,SAAS,CAACgD,QAAQ,CAAC;UACtD,MAAM,IAAAC,yBAAc,EAACtC,OAAO,CAACX,SAAS,CAACgD,QAAQ,EAAE,MAAOE,GAAG,IAAK;YAC5DJ,OAAO,GAAG,EAAE;YACZ,IAAM,CACFK,gBAAgB,EAChBC,mBAAmB,CACtB,GAAG,MAAMC,OAAO,CAACC,GAAG,CAAC,CAClB,IAAAC,kBAAO,EAACnB,UAAU,CAAC,EACnBC,aAAa,GAAG,IAAAkB,kBAAO,EAAClB,aAAa,CAAC,GAAGR,SAAS,CACrD,CAAC;YAEF,IACIsB,gBAAgB,CAACK,QAAQ,CAACC,gBAAgB,IACzCpB,aAAa,IAAI,IAAAqB,qBAAc,EAACN,mBAAmB,CAAC,CAACI,QAAQ,CAACC,gBAAiB,EAClF;cACE;YACJ,CAAC,MAAM;cACHZ,UAAU,GAAG,KAAK;cAElB,IAAIR,aAAa,EAAE;gBACfS,OAAO,GAAG,IAAAY,qBAAc,EAACN,mBAAmB,CAAC,CAACO,IAAW;cAC7D;cACA,IAAMC,aAAa,GAAGzB,SAAS,GAAGW,OAAO,CAACe,MAAM;cAChD,IAAID,aAAa,GAAG,CAAC,EAAE;gBACnB,IAAME,cAAc,GAAGX,gBAAgB,CAACQ,IAAI,CAACI,KAAK,CAAC,CAAC,EAAEH,aAAa,CAAC,CAAChC,MAAM,CAACoC,CAAC,IAAI,CAAC,CAACA,CAAC,CAAC;gBACrF,IAAAC,oBAAa,EAACnB,OAAO,EAAEgB,cAAc,CAAC;cAC1C;YACJ;UACJ,CAAC,CAAC;QACN;QAEA,IAAIhB,OAAO,CAACe,MAAM,KAAK,CAAC,EAAE;UACtB,OAAO;YACHK,UAAU,EAAEhC,oBAAoB;YAChCiC,SAAS,EAAE;UACf,CAAC;QACL;QACA,IAAMC,OAAO,GAAG,IAAAV,qBAAc,EAAC,IAAAW,kBAAW,EAACvB,OAAO,CAAC,CAAC;QACpD,IAAMqB,SAAmC,GAAGrB,OAAO,CAC9CwB,GAAG,CAACC,GAAG,IAAI,IAAAC,sCAAqB,EAC7BtD,oBAAoB,EACpBC,WAAW,EACXoD,GACJ,CAAC,CAAC;QACN,IAAME,aAAsC,GAAG;UAC3C7B,EAAE,EAAEwB,OAAO,CAACxB,EAAE;UACdJ,eAAe,EAAE,IAAAkC,2CAA0B,EAACxD,oBAAoB,EAAEkD,OAAO,CAACO,IAAI,CAAC,CAAC;QACpF,CAAC;QACD,IAAMC,GAAG,GAAG;UACRT,SAAS,EAAEA,SAAS;UACpBD,UAAU,EAAEO;QAChB,CAAC;QACD,OAAOG,GAAG;MACd,CAAC;MACDzC,SAAS,EAAE,IAAAuB,qBAAc,EAAC/C,OAAO,CAACR,IAAI,CAAC,CAACgC,SAAS;MACjD0C,QAAQ,EAAE,IAAAnB,qBAAc,EAAC/C,OAAO,CAACR,IAAI,CAAC,CAAC0E,QAAQ;MAC/CC,OAAO,EAAEhE,WAAW,CAACiE,YAAY,CAAC;IACtC,CAAC;EACL;EAEA,IAAIC,yBAAwE;EAC5E,IAAIrE,OAAO,CAACP,IAAI,EAAE;IACd,IAAM6E,UAAU,GAAGtE,OAAO,CAACP,IAAI,EAAEwB,MAAM;IACvCoD,yBAAyB,GAAG;MACxB,MAAM/C,OAAOA,CACTiD,IAAgD,EAClD;QACE,IAAID,UAAU,KAAKpD,SAAS,EAAE;UAC1BqD,IAAI,GAAG,MAAM,IAAAC,kBAAW,EAACD,IAAI,EAAGX,GAAG,IAAKU,UAAU,CAACV,GAAG,CAACa,gBAAgB,CAAC,CAAC;QAC7E;QAEA,IAAMC,aAA6D,GAAG,CAAC,CAAC;QACxE,IAAMC,MAAgB,GAAGJ,IAAI,CAACZ,GAAG,CAACC,GAAG,IAAI;UACrC,IAAMgB,KAAK,GAAIhB,GAAG,CAACa,gBAAgB,CAASjE,WAAW,CAAC;UACxDkE,aAAa,CAACE,KAAK,CAAC,GAAGhB,GAAG;UAC1B,OAAOgB,KAAK;QAChB,CAAC,CAAC;QACF,MAAM,IAAAxC,+BAAoB,EAACpC,OAAO,CAACX,SAAS,CAACgD,QAAQ,CAAC;QACtD,IAAIwC,SAAmC,GAAG,EAAE;;QAE5C;AAChB;AACA;AACA;AACA;AACA;QACgB,MAAM,IAAAvC,yBAAc,EAACtC,OAAO,CAACX,SAAS,CAACgD,QAAQ,EAAE,MAAOE,GAAG,IAAK;UAC5DsC,SAAS,GAAG,EAAE,CAAC,CAAC;UAChB;AACpB;AACA;;UAEoB,IAAMC,QAAQ,GAAIC,GAAa,IAAK;YAChC,OAAO,IAAAnC,kBAAO,EACV,IAAAvB,gBAAK,EACDrB,OAAO,CAACX,SAAS,CAACE,UAAU,EAC5B,IAAAuC,gBAAK,EAAC,IAAAkD,qBAAU,EAAC,CAAC,EAAE,IAAI,EAAED,GAAG,CACjC,CACJ,CAAC;UACL,CAAC;UAED,IAAME,cAAc,GAAG,MAAM,IAAAC,gCAAe,EAAYP,MAAM,EAAEG,QAAQ,CAAC;UAEzE,IAAMK,YAA6B,GAAG,CAAC,CAAC;UACxCF,cAAc,CAAC3G,OAAO,CAACsF,GAAG,IAAI;YAC1B,IAAMwB,WAAW,GAAG,IAAAC,0CAAyB,EAAC9E,oBAAoB,EAAEqD,GAAG,CAACI,IAAI,CAAC,CAAC,CAAC;YAC/E,IAAMY,KAAK,GAAGhB,GAAG,CAAC3B,EAAE;YACnBmD,WAAW,CAAS5E,WAAW,CAAC,GAAGoE,KAAK;YACzCO,YAAY,CAACP,KAAK,CAAC,GAAGQ,WAAW;UACrC,CAAC,CAAC;;UAEF;AACpB;AACA;UACoB,IAAME,KAAK,GAAG,IAAAC,qBAAU,EAACvF,OAAO,CAACX,SAAS,CAACgD,QAAQ,CAAC;UACpD,IAAImD,QAAQ,GAAG,KAAK;UACpB,MAAM9C,OAAO,CAACC,GAAG,CACbvE,MAAM,CAACqH,OAAO,CAACf,aAAa,CAAC,CAACf,GAAG,CAAC,OAAO,CAACiB,KAAK,EAAEc,QAAQ,CAAC,KAAK;YAC3D,IAAMC,OAA8B,GAAGR,YAAY,CAACP,KAAK,CAAC;YAE1D,IACIe,OAAO,KAEH,CAACD,QAAQ,CAACE,kBAAkB,IAC5B,CAAC,MAAMrG,UAAU,CAACsG,eAAe,CAAC;cAC9BpB,gBAAgB,EAAEkB,OAAc;cAChCG,eAAe,EAAEJ,QAAQ,CAACE;YAC9B,CAAC,EAAE,4BAA4B,CAAC,EAAEG,OAAO,KAAK,KAAK,CACtD,EACH;cACE;cACAlB,SAAS,CAACpF,IAAI,CAACkG,OAAc,CAAC;YAClC,CAAC,MAAM;cACH;cACAH,QAAQ,GAAG,IAAI;cACf,IAAMQ,MAAM,GAAG,IAAAC,cAAG,EAACjG,OAAO,CAACX,SAAS,CAACE,UAAU,EAAEqF,KAAK,CAAC;cACvD,IAAMsB,YAAY,GAAG,IAAAC,gBAAS,EAACT,QAAQ,CAACjB,gBAAgB,CAAC;cACxDyB,YAAY,CAAS3F,oBAAoB,CAAC,GAAG,IAAAsB,0BAAe,EAAC,CAAC;cAC/D,IAAI,CAAC8D,OAAO,EAAE;gBACV;gBACAL,KAAK,CAACc,GAAG,CAACJ,MAAM,EAAE,IAAAK,gCAAe,EAAC7F,WAAW,EAAE0F,YAAY,CAAC,CAAC;cACjE,CAAC,MAAM;gBACH;gBACAZ,KAAK,CAACgB,MAAM,CAACN,MAAM,EAAE,IAAAK,gCAAe,EAAC7F,WAAW,EAAE0F,YAAY,CAAC,CAAC;cACpE;YACJ;UACJ,CAAC,CACL,CAAC;UAED,IAAIV,QAAQ,EAAE;YACV,MAAMF,KAAK,CAACiB,MAAM,CAAC,CAAC;UACxB;QACJ,CAAC,CAAC;QACF,MAAM,IAAAnE,+BAAoB,EAACpC,OAAO,CAACX,SAAS,CAACgD,QAAQ,CAAC;QACtD,OAAOwC,SAAS;MACpB,CAAC;MACDrD,SAAS,EAAExB,OAAO,CAACP,IAAI,CAAC+B,SAAS;MACjC0C,QAAQ,EAAElE,OAAO,CAACP,IAAI,CAACyE;IAC3B,CAAC;EACL;EAGA,IAAMsC,gBAAgB,GAAG,IAAIvH,2BAA2B,CACpDe,OAAO,CAACX,SAAS,EACjBoH,6DAA4C,GAAGzG,OAAO,CAACT,UAAU,CAAC8C,QAAQ,CAACqE,YAAY,CAAC1G,OAAO,CAACX,SAAS,CAACsH,SAAS,CAAC,EACpHpH,UAAU,EACVc,yBAAyB,EACzBgE,yBAAyB,EACzBrE,OAAO,CAACN,IAAI,EACZM,OAAO,CAACL,SAAS,EACjBK,OAAO,CAACJ,SACZ,CAAC;;EAED;AACJ;AACA;EACI,IAAII,OAAO,CAACN,IAAI,IAAIM,OAAO,CAACR,IAAI,EAAE;IAC9B,IAAMoH,WAAW,GAAGJ,gBAAgB,CAACK,KAAK,CAACC,IAAI,CAACN,gBAAgB,CAAC;IACjE,IAAMO,YAAY,GAAGP,gBAAgB,CAACQ,MAAM,CAACF,IAAI,CAACN,gBAAgB,CAAC;IACnEA,gBAAgB,CAACK,KAAK,GAAG,MAAM;MAC3B,IAAMI,eAAe,GAAG,IAAA5F,gBAAK,EACzBD,SAAS,EACT,IAAAW,kBAAO,EAACxB,oBAAoB,EAAE,MAAM,CAAC,EACrC,IAAAyB,gBAAK,EAAC,CAAC,CACX,CAAC;MACD,IAAMkF,WAAW,GAAG,IAAAC,qBAAU,EAC1BF,eAAe,EACdG,cAAc,IAAK;QAChB;AACpB;AACA;AACA;AACA;QACoBZ,gBAAgB,CAACa,MAAM,CAAC,CAAC;MAC7B,CAAC,EACAC,KAAK,IAAK;QACPd,gBAAgB,CAACe,QAAQ,CAACD,KAAK,CAACE,IAAI,CAChC,IAAA1G,YAAU,EAAC,WAAW,EAAE;UAAEwG,KAAK,EAAE,IAAAG,uBAAgB,EAACH,KAAK;QAAE,CAAC,CAC9D,CAAC;MACL,CACJ,CAAC;MACDd,gBAAgB,CAACQ,MAAM,GAAG,MAAM;QAC5BE,WAAW,CAAC,CAAC;QACb,OAAOH,YAAY,CAAC,CAAC;MACzB,CAAC;MACD,OAAOH,WAAW,CAAC,CAAC;IACxB,CAAC;EACL;EAEA,IAAAc,yCAA4B,EAAC1H,OAAO,CAACM,iBAAiB,EAAEkG,gBAAgB,CAAC;EAEzE,OAAOA,gBAAgB;AAC3B"}
\ No newline at end of file
diff --git a/node_modules/rxdb/dist/types/plugins/encryption-crypto-js/index.d.ts b/node_modules/rxdb/dist/types/plugins/encryption-crypto-js/index.d.ts
deleted file mode 100644
index 3d17d46..0000000
--- a/node_modules/rxdb/dist/types/plugins/encryption-crypto-js/index.d.ts
+++ /dev/null
@@ -1,10 +0,0 @@
-import type { InternalStoreDocType, RxStorage } from '../../types';
-export declare const MINIMUM_PASSWORD_LENGTH: 8;
-export declare function encryptString(value: string, password: string): string;
-export declare function decryptString(cipherText: string, password: any): string;
-export type InternalStorePasswordDocType = InternalStoreDocType<{
-    hash: string;
-}>;
-export declare function wrappedKeyEncryptionCryptoJsStorage<Internals, InstanceCreationOptions>(args: {
-    storage: RxStorage<Internals, InstanceCreationOptions>;
-}): RxStorage<Internals, InstanceCreationOptions>;
diff --git a/node_modules/rxdb/dist/types/plugins/replication-firestore/firestore-helper.d.ts b/node_modules/rxdb/dist/types/plugins/replication-firestore/firestore-helper.d.ts
deleted file mode 100644
index 4b63d84..0000000
--- a/node_modules/rxdb/dist/types/plugins/replication-firestore/firestore-helper.d.ts
+++ /dev/null
@@ -1,11 +0,0 @@
-import { QueryDocumentSnapshot, Timestamp } from 'firebase/firestore';
-import type { WithDeleted } from '../../types';
-import type { GetQuery } from './firestore-types';
-export declare const FIRESTORE_REPLICATION_PLUGIN_IDENTITY_PREFIX = "firestore";
-export declare function getFirestoreSortFieldValue(docData: any, primaryKey: string): string;
-export declare function stripServerTimestampField<RxDocType>(serverTimestampField: string, docData: RxDocType): WithDeleted<RxDocType>;
-export declare function serverTimestampToIsoString(serverTimestampField: string, docData: any): string;
-export declare function isoStringToServerTimestamp(isoString: string): Timestamp;
-export declare function firestoreRowToDocData<RxDocType>(serverTimestampField: string, primaryPath: string, row: QueryDocumentSnapshot<RxDocType>): WithDeleted<RxDocType>;
-export declare function stripPrimaryKey(primaryPath: string, docData: any): any;
-export declare function getContentByIds<RxDocType>(ids: string[], getQuery: GetQuery<RxDocType>): Promise<QueryDocumentSnapshot<RxDocType>[]>;
diff --git a/node_modules/rxdb/dist/types/plugins/replication-firestore/firestore-types.d.ts b/node_modules/rxdb/dist/types/plugins/replication-firestore/firestore-types.d.ts
deleted file mode 100644
index d5bc338..0000000
--- a/node_modules/rxdb/dist/types/plugins/replication-firestore/firestore-types.d.ts
+++ /dev/null
@@ -1,46 +0,0 @@
-import type { MaybePromise, ReplicationOptions, ReplicationPullOptions, ReplicationPushOptions, WithDeleted } from '../../types';
-import type { CollectionReference, Firestore, QueryFieldFilterConstraint, QuerySnapshot } from 'firebase/firestore';
-export type FirestoreCheckpointType = {
-    id: string;
-    /**
-     * Firestore internally sets the time to an object like
-     * {
-     *       "seconds": 1669807105,
-     *       "nanoseconds": 476000000
-     * }
-     * But to be able to query that, we have to use a date string
-     * like '2022-11-30T11:18:25.141Z'
-     * so we store that string instead.
-     */
-    serverTimestamp: string;
-};
-export type FirestoreCollection<RxDocType> = CollectionReference<RxDocType>;
-export type FirestoreOptions<RxDocType> = {
-    projectId: string;
-    collection: FirestoreCollection<RxDocType>;
-    database: Firestore;
-};
-export type FirestoreSyncPullOptions<RxDocType> = Omit<ReplicationPullOptions<RxDocType, FirestoreCheckpointType>, 'handler' | 'stream$'> & {
-    filter?: QueryFieldFilterConstraint | QueryFieldFilterConstraint[];
-};
-export type FirestoreSyncPushOptions<RxDocType> = Omit<ReplicationPushOptions<RxDocType>, 'handler'> & {
-    filter?(item: WithDeleted<RxDocType>): MaybePromise<boolean>;
-};
-export type SyncOptionsFirestore<RxDocType> = Omit<ReplicationOptions<RxDocType, any>, 'pull' | 'push' | 'replicationIdentifier'> & {
-    firestore: FirestoreOptions<RxDocType>;
-    /**
-     * In firestore it is not possible to read out
-     * the internally used write timestamp.
-     * Even if we could read it out, it is not indexed which
-     * is required for fetch 'changes-since-x'.
-     * So instead we have to rely on a custom user defined field
-     * that contains the server time which is set by firestore via serverTimestamp()
-     * IMPORTANT: The serverTimestampField MUST NOT be part of the collections RxJsonSchema!
-     * [default='serverTimestamp']
-     * @link https://groups.google.com/g/firebase-talk/c/tAmPzPei-mE
-     */
-    serverTimestampField?: string;
-    pull?: FirestoreSyncPullOptions<RxDocType>;
-    push?: FirestoreSyncPushOptions<RxDocType>;
-};
-export type GetQuery<RxDocType> = (ids: string[]) => Promise<QuerySnapshot<RxDocType>>;
diff --git a/node_modules/rxdb/dist/types/plugins/replication-firestore/index.d.ts b/node_modules/rxdb/dist/types/plugins/replication-firestore/index.d.ts
deleted file mode 100644
index afebc53..0000000
--- a/node_modules/rxdb/dist/types/plugins/replication-firestore/index.d.ts
+++ /dev/null
@@ -1,17 +0,0 @@
-import type { RxCollection, ReplicationPullOptions, ReplicationPushOptions } from '../../types';
-import { RxReplicationState } from '../replication';
-import type { FirestoreCheckpointType, FirestoreOptions, SyncOptionsFirestore } from './firestore-types';
-export * from './firestore-helper';
-export * from './firestore-types';
-export declare class RxFirestoreReplicationState<RxDocType> extends RxReplicationState<RxDocType, FirestoreCheckpointType> {
-    readonly firestore: FirestoreOptions<RxDocType>;
-    readonly replicationIdentifierHash: string;
-    readonly collection: RxCollection<RxDocType>;
-    readonly pull?: ReplicationPullOptions<RxDocType, FirestoreCheckpointType> | undefined;
-    readonly push?: ReplicationPushOptions<RxDocType> | undefined;
-    readonly live: boolean;
-    retryTime: number;
-    autoStart: boolean;
-    constructor(firestore: FirestoreOptions<RxDocType>, replicationIdentifierHash: string, collection: RxCollection<RxDocType>, pull?: ReplicationPullOptions<RxDocType, FirestoreCheckpointType> | undefined, push?: ReplicationPushOptions<RxDocType> | undefined, live?: boolean, retryTime?: number, autoStart?: boolean);
-}
-export declare function replicateFirestore<RxDocType>(options: SyncOptionsFirestore<RxDocType>): RxFirestoreReplicationState<RxDocType>;
diff --git a/node_modules/rxdb/patched/enabled b/node_modules/rxdb/patched/enabled
new file mode 100644
index 0000000..f32a580
--- /dev/null
+++ b/node_modules/rxdb/patched/enabled
@@ -0,0 +1 @@
+true
\ No newline at end of file
diff --git a/node_modules/rxdb/plugins/encryption-crypto-js/package.json b/node_modules/rxdb/plugins/encryption-crypto-js/package.json
deleted file mode 100644
index 423671b..0000000
--- a/node_modules/rxdb/plugins/encryption-crypto-js/package.json
+++ /dev/null
@@ -1,10 +0,0 @@
-{
-    "name": "rxdb-plugins-encryption-crypto-js",
-    "description": "This package.json file is generated by the \"npm run build:plugins\" script, do not edit it manually!",
-    "main": "../../dist/lib/plugins/encryption-crypto-js/index.js",
-    "module": "../../dist/es/plugins/encryption-crypto-js/index.js",
-    "es2015": "../../dist/es/plugins/encryption-crypto-js/index.js",
-    "jsnext:main": "../../dist/es/plugins/encryption-crypto-js/index.js",
-    "types": "../../dist/types/plugins/encryption-crypto-js/index.d.ts",
-    "sideEffects": false
-}
\ No newline at end of file
diff --git a/node_modules/rxdb/plugins/replication-firestore/package.json b/node_modules/rxdb/plugins/replication-firestore/package.json
deleted file mode 100644
index a5101a9..0000000
--- a/node_modules/rxdb/plugins/replication-firestore/package.json
+++ /dev/null
@@ -1,10 +0,0 @@
-{
-    "name": "rxdb-plugins-replication-firestore",
-    "description": "This package.json file is generated by the \"npm run build:plugins\" script, do not edit it manually!",
-    "main": "../../dist/lib/plugins/replication-firestore/index.js",
-    "module": "../../dist/es/plugins/replication-firestore/index.js",
-    "es2015": "../../dist/es/plugins/replication-firestore/index.js",
-    "jsnext:main": "../../dist/es/plugins/replication-firestore/index.js",
-    "types": "../../dist/types/plugins/replication-firestore/index.d.ts",
-    "sideEffects": false
-}
\ No newline at end of file
diff --git a/node_modules/rxdb/src/plugins/encryption-crypto-js/index.ts b/node_modules/rxdb/src/plugins/encryption-crypto-js/index.ts
deleted file mode 100644
index 71b970b..0000000
--- a/node_modules/rxdb/src/plugins/encryption-crypto-js/index.ts
+++ /dev/null
@@ -1,202 +0,0 @@
-/**
- * this plugin adds the encryption-capabilities to rxdb
- * It's using crypto-js/aes for password-encryption
- * @link https://github.com/brix/crypto-js
- */
-import AES from 'crypto-js/aes';
-import * as cryptoEnc from 'crypto-js/enc-utf8';
-import { wrapRxStorageInstance } from '../../plugin-helpers';
-import { newRxError, newRxTypeError } from '../../rx-error';
-import { hasEncryption } from '../../rx-storage-helper';
-import type {
-    InternalStoreDocType,
-    RxAttachmentWriteData,
-    RxDocumentData,
-    RxDocumentWriteData,
-    RxJsonSchema,
-    RxStorage,
-    RxStorageInstanceCreationParams
-} from '../../types';
-import {
-    b64DecodeUnicode,
-    b64EncodeUnicode,
-    clone,
-    ensureNotFalsy,
-    flatClone,
-    getProperty,
-    setProperty
-} from '../../plugins/utils';
-
-export const MINIMUM_PASSWORD_LENGTH: 8 = 8;
-
-
-export function encryptString(value: string, password: string): string {
-    const encrypted = AES.encrypt(value, password);
-    return encrypted.toString();
-}
-
-export function decryptString(cipherText: string, password: any): string {
-    /**
-     * Trying to decrypt non-strings
-     * will cause no errors and will be hard to debug.
-     * So instead we do this check here.
-     */
-    if (typeof cipherText !== 'string') {
-        throw newRxError('SNH', {
-            args: {
-                cipherText
-            }
-        });
-    }
-
-    const decrypted = AES.decrypt(cipherText, password);
-    const ret = decrypted.toString(cryptoEnc);
-    return ret;
-}
-
-export type InternalStorePasswordDocType = InternalStoreDocType<{
-    hash: string;
-}>;
-
-export function wrappedKeyEncryptionCryptoJsStorage<Internals, InstanceCreationOptions>(
-    args: {
-        storage: RxStorage<Internals, InstanceCreationOptions>;
-    }
-): RxStorage<Internals, InstanceCreationOptions> {
-    return Object.assign(
-        {},
-        args.storage,
-        {
-            async createStorageInstance<RxDocType>(
-                params: RxStorageInstanceCreationParams<RxDocType, any>
-            ) {
-                if (typeof params.password !== 'undefined') {
-                    validatePassword(params.password as any);
-                }
-
-                if (!hasEncryption(params.schema)) {
-                    const retInstance = await args.storage.createStorageInstance(params);
-                    return retInstance;
-                }
-
-                if (!params.password) {
-                    throw newRxError('EN3', {
-                        database: params.databaseName,
-                        collection: params.collectionName,
-                        schema: params.schema
-                    });
-                }
-                const password = params.password;
-
-                const schemaWithoutEncrypted: RxJsonSchema<RxDocumentData<RxDocType>> = clone(params.schema);
-                delete schemaWithoutEncrypted.encrypted;
-                if (schemaWithoutEncrypted.attachments) {
-                    schemaWithoutEncrypted.attachments.encrypted = false;
-                }
-
-                const instance = await args.storage.createStorageInstance(
-                    Object.assign(
-                        {},
-                        params,
-                        {
-                            schema: schemaWithoutEncrypted
-                        }
-                    )
-                );
-
-                function modifyToStorage(docData: RxDocumentWriteData<RxDocType>) {
-                    docData = cloneWithoutAttachments(docData);
-                    ensureNotFalsy(params.schema.encrypted)
-                        .forEach(path => {
-                            const value = getProperty(docData, path);
-                            if (typeof value === 'undefined') {
-                                return;
-                            }
-
-                            const stringValue = JSON.stringify(value);
-                            const encrypted = encryptString(stringValue, password);
-                            setProperty(docData, path, encrypted);
-                        });
-
-                    // handle attachments
-                    if (
-                        params.schema.attachments &&
-                        params.schema.attachments.encrypted
-                    ) {
-                        const newAttachments: typeof docData._attachments = {};
-                        Object.entries(docData._attachments).forEach(([id, attachment]) => {
-                            const useAttachment: RxAttachmentWriteData = flatClone(attachment) as any;
-                            if (useAttachment.data) {
-                                const dataString = useAttachment.data;
-                                useAttachment.data = b64EncodeUnicode(encryptString(dataString, password));
-                            }
-                            newAttachments[id] = useAttachment;
-                        });
-                        docData._attachments = newAttachments;
-                    }
-                    return docData;
-                }
-                function modifyFromStorage(docData: RxDocumentData<any>): Promise<RxDocumentData<RxDocType>> {
-                    docData = cloneWithoutAttachments(docData);
-                    ensureNotFalsy(params.schema.encrypted)
-                        .forEach(path => {
-                            const value = getProperty(docData, path);
-                            if (typeof value === 'undefined') {
-                                return;
-                            }
-                            const decrypted = decryptString(value, password);
-                            const decryptedParsed = JSON.parse(decrypted);
-                            setProperty(docData, path, decryptedParsed);
-                        });
-                    return docData;
-                }
-
-                function modifyAttachmentFromStorage(attachmentData: string): string {
-                    if (
-                        params.schema.attachments &&
-                        params.schema.attachments.encrypted
-                    ) {
-                        const decrypted = decryptString(b64DecodeUnicode(attachmentData), password);
-                        return decrypted;
-                    } else {
-                        return attachmentData;
-                    }
-                }
-
-                return wrapRxStorageInstance(
-                    instance,
-                    modifyToStorage,
-                    modifyFromStorage,
-                    modifyAttachmentFromStorage
-                );
-            }
-        }
-    );
-}
-
-
-
-
-
-function cloneWithoutAttachments<T>(data: RxDocumentWriteData<T>): RxDocumentData<T> {
-    const attachments = data._attachments;
-    data = flatClone(data);
-    delete (data as any)._attachments;
-    data = clone(data);
-    data._attachments = attachments;
-    return data as any;
-}
-
-function validatePassword(password: string) {
-    if (typeof password !== 'string') {
-        throw newRxTypeError('EN1', {
-            password
-        });
-    }
-    if (password.length < MINIMUM_PASSWORD_LENGTH) {
-        throw newRxError('EN2', {
-            minPassLength: MINIMUM_PASSWORD_LENGTH,
-            password
-        });
-    }
-}
diff --git a/node_modules/rxdb/src/plugins/replication-firestore/firestore-helper.ts b/node_modules/rxdb/src/plugins/replication-firestore/firestore-helper.ts
deleted file mode 100644
index ad34bbd..0000000
--- a/node_modules/rxdb/src/plugins/replication-firestore/firestore-helper.ts
+++ /dev/null
@@ -1,76 +0,0 @@
-import {
-    QueryDocumentSnapshot,
-    Timestamp
-} from 'firebase/firestore';
-import type {
-    WithDeleted
-} from '../../types';
-import { flatClone, now } from '../../plugins/utils';
-import type { GetQuery } from './firestore-types';
-
-export const FIRESTORE_REPLICATION_PLUGIN_IDENTITY_PREFIX = 'firestore';
-
-
-export function getFirestoreSortFieldValue(docData: any, primaryKey: string): string {
-    const timeString = now() + '';
-    return 'rxdb-' + timeString.padStart(15, '0') + '-' + docData[primaryKey];
-}
-
-export function stripServerTimestampField<RxDocType>(
-    serverTimestampField: string,
-    docData: RxDocType
-): WithDeleted<RxDocType> {
-    const data = flatClone(docData);
-    delete (data as any)[serverTimestampField];
-    return data as any;
-}
-
-
-export function serverTimestampToIsoString(serverTimestampField: string, docData: any): string {
-    const timestamp = (docData as any)[serverTimestampField];
-    const date: Date = timestamp.toDate();
-    return date.toISOString();
-}
-
-export function isoStringToServerTimestamp(isoString: string): Timestamp {
-    const date = new Date(isoString);
-    return Timestamp.fromDate(date);
-}
-
-export function firestoreRowToDocData<RxDocType>(
-    serverTimestampField: string,
-    primaryPath: string,
-    row: QueryDocumentSnapshot<RxDocType>
-): WithDeleted<RxDocType> {
-    const docData = stripServerTimestampField(
-        serverTimestampField,
-        row.data()
-    );
-    (docData as any)[primaryPath] = row.id;
-    return docData;
-}
-
-export function stripPrimaryKey(
-    primaryPath: string,
-    docData: any
-): any {
-    docData = flatClone(docData);
-    delete (docData as any)[primaryPath];
-    return docData;
-}
-
-// https://stackoverflow.com/questions/61354866/is-there-a-workaround-for-the-firebase-query-in-limit-to-10
-export function getContentByIds<RxDocType>(ids: string[], getQuery: GetQuery<RxDocType>): Promise<QueryDocumentSnapshot<RxDocType>[]> {
-    const batches = [];
-
-    while (ids.length) {
-        // firestore limits batches to 10
-        const batch = ids.splice(0, 10);
-
-        // add the batch request to to a queue
-        batches.push(getQuery(batch));
-    }
-
-    // after all of the data is fetched, return it
-    return Promise.all(batches).then((content) => content.map(i => i.docs).flat());
-}
diff --git a/node_modules/rxdb/src/plugins/replication-firestore/firestore-types.ts b/node_modules/rxdb/src/plugins/replication-firestore/firestore-types.ts
deleted file mode 100644
index 6f653ac..0000000
--- a/node_modules/rxdb/src/plugins/replication-firestore/firestore-types.ts
+++ /dev/null
@@ -1,70 +0,0 @@
-import type {
-    MaybePromise,
-    ReplicationOptions,
-    ReplicationPullOptions,
-    ReplicationPushOptions,
-    WithDeleted
-} from '../../types';
-
-import type {
-    CollectionReference,
-    Firestore,
-    QueryFieldFilterConstraint,
-    QuerySnapshot
-} from 'firebase/firestore';
-
-export type FirestoreCheckpointType = {
-    id: string;
-    /**
-     * Firestore internally sets the time to an object like
-     * {
-     *       "seconds": 1669807105,
-     *       "nanoseconds": 476000000
-     * }
-     * But to be able to query that, we have to use a date string
-     * like '2022-11-30T11:18:25.141Z'
-     * so we store that string instead.
-     */
-    serverTimestamp: string;
-};
-export type FirestoreCollection<RxDocType> = CollectionReference<RxDocType>;
-
-export type FirestoreOptions<RxDocType> = {
-    projectId: string;
-    collection: FirestoreCollection<RxDocType>;
-    database: Firestore;
-};
-
-export type FirestoreSyncPullOptions<RxDocType> =
-    Omit<ReplicationPullOptions<RxDocType, FirestoreCheckpointType>, 'handler' | 'stream$'>
-    & {
-        filter?: QueryFieldFilterConstraint | QueryFieldFilterConstraint[];
-    };
-
-export type FirestoreSyncPushOptions<RxDocType> = Omit<ReplicationPushOptions<RxDocType>, 'handler'>
-    & {
-        filter?(item: WithDeleted<RxDocType>): MaybePromise<boolean>;
-    };
-
-export type SyncOptionsFirestore<RxDocType> = Omit<
-    ReplicationOptions<RxDocType, any>,
-    'pull' | 'push' | 'replicationIdentifier'
-> & {
-    firestore: FirestoreOptions<RxDocType>;
-    /**
-     * In firestore it is not possible to read out
-     * the internally used write timestamp.
-     * Even if we could read it out, it is not indexed which
-     * is required for fetch 'changes-since-x'.
-     * So instead we have to rely on a custom user defined field
-     * that contains the server time which is set by firestore via serverTimestamp()
-     * IMPORTANT: The serverTimestampField MUST NOT be part of the collections RxJsonSchema!
-     * [default='serverTimestamp']
-     * @link https://groups.google.com/g/firebase-talk/c/tAmPzPei-mE
-     */
-    serverTimestampField?: string;
-    pull?: FirestoreSyncPullOptions<RxDocType>;
-    push?: FirestoreSyncPushOptions<RxDocType>;
-};
-
-export type GetQuery<RxDocType> = (ids: string[]) => Promise<QuerySnapshot<RxDocType>>;
diff --git a/node_modules/rxdb/src/plugins/replication-firestore/index.ts b/node_modules/rxdb/src/plugins/replication-firestore/index.ts
deleted file mode 100644
index 81e7043..0000000
--- a/node_modules/rxdb/src/plugins/replication-firestore/index.ts
+++ /dev/null
@@ -1,374 +0,0 @@
-import {
-    appendToArray,
-    asyncFilter,
-    ensureNotFalsy,
-    errorToPlainJson,
-    flatClone,
-    lastOfArray,
-    toArray
-} from '../../plugins/utils';
-
-import {
-    doc,
-    query,
-    where,
-    orderBy,
-    limit,
-    getDocs,
-    onSnapshot,
-    runTransaction,
-    writeBatch,
-    serverTimestamp,
-    QueryDocumentSnapshot,
-    waitForPendingWrites,
-    documentId
-} from 'firebase/firestore';
-
-import { RxDBLeaderElectionPlugin } from '../leader-election';
-import type {
-    RxCollection,
-    ReplicationPullOptions,
-    ReplicationPushOptions,
-    RxReplicationWriteToMasterRow,
-    RxReplicationPullStreamItem
-} from '../../types';
-import {
-    RxReplicationState,
-    startReplicationOnLeaderShip
-} from '../replication';
-import {
-    addRxPlugin,
-    ById,
-    getSchemaByObjectPath,
-    newRxError,
-    WithDeleted
-} from '../../';
-
-import type {
-    FirestoreCheckpointType,
-    FirestoreOptions,
-    SyncOptionsFirestore
-} from './firestore-types';
-import { Subject } from 'rxjs';
-import {
-    firestoreRowToDocData,
-    FIRESTORE_REPLICATION_PLUGIN_IDENTITY_PREFIX,
-    getContentByIds,
-    isoStringToServerTimestamp,
-    serverTimestampToIsoString,
-    stripPrimaryKey,
-    stripServerTimestampField
-} from './firestore-helper';
-
-export * from './firestore-helper';
-export * from './firestore-types';
-
-export class RxFirestoreReplicationState<RxDocType> extends RxReplicationState<RxDocType, FirestoreCheckpointType> {
-    constructor(
-        public readonly firestore: FirestoreOptions<RxDocType>,
-        public readonly replicationIdentifierHash: string,
-        public readonly collection: RxCollection<RxDocType>,
-        public readonly pull?: ReplicationPullOptions<RxDocType, FirestoreCheckpointType>,
-        public readonly push?: ReplicationPushOptions<RxDocType>,
-        public readonly live: boolean = true,
-        public retryTime: number = 1000 * 5,
-        public autoStart: boolean = true
-    ) {
-        super(
-            replicationIdentifierHash,
-            collection,
-            '_deleted',
-            pull,
-            push,
-            live,
-            retryTime,
-            autoStart
-        );
-    }
-}
-
-export function replicateFirestore<RxDocType>(
-    options: SyncOptionsFirestore<RxDocType>
-): RxFirestoreReplicationState<RxDocType> {
-    const collection = options.collection;
-    addRxPlugin(RxDBLeaderElectionPlugin);
-    const pullStream$: Subject<RxReplicationPullStreamItem<RxDocType, FirestoreCheckpointType>> = new Subject();
-    let replicationPrimitivesPull: ReplicationPullOptions<RxDocType, FirestoreCheckpointType> | undefined;
-    options.live = typeof options.live === 'undefined' ? true : options.live;
-    options.waitForLeadership = typeof options.waitForLeadership === 'undefined' ? true : options.waitForLeadership;
-    const serverTimestampField = typeof options.serverTimestampField === 'undefined' ? 'serverTimestamp' : options.serverTimestampField;
-    options.serverTimestampField = serverTimestampField;
-    const primaryPath = collection.schema.primaryPath;
-
-    /**
-     * The serverTimestampField MUST NOT be part of the collections RxJsonSchema.
-     */
-    const schemaPart = getSchemaByObjectPath(collection.schema.jsonSchema, serverTimestampField);
-    if (
-        schemaPart ||
-        // also must not be nested.
-        serverTimestampField.includes('.')
-    ) {
-        throw newRxError('RC6', {
-            field: serverTimestampField,
-            schema: collection.schema.jsonSchema
-        });
-    }
-
-    const pullFilters = options.pull?.filter !== undefined
-        ? toArray(options.pull.filter)
-        : [];
-
-    const pullQuery = query(options.firestore.collection, ...pullFilters);
-
-    if (options.pull) {
-        replicationPrimitivesPull = {
-            async handler(
-                lastPulledCheckpoint: FirestoreCheckpointType,
-                batchSize: number
-            ) {
-                let newerQuery: ReturnType<typeof query>;
-                let sameTimeQuery: ReturnType<typeof query> | undefined;
-
-                if (lastPulledCheckpoint) {
-                    const lastServerTimestamp = isoStringToServerTimestamp(lastPulledCheckpoint.serverTimestamp);
-                    newerQuery = query(pullQuery,
-                        where(serverTimestampField, '>', lastServerTimestamp),
-                        orderBy(serverTimestampField, 'asc'),
-                        limit(batchSize)
-                    );
-                    sameTimeQuery = query(pullQuery,
-                        where(serverTimestampField, '==', lastServerTimestamp),
-                        where(primaryPath, '>', lastPulledCheckpoint.id),
-                        orderBy(primaryPath, 'asc'),
-                        limit(batchSize)
-                    );
-                } else {
-                    newerQuery = query(pullQuery,
-                        orderBy(serverTimestampField, 'asc'),
-                        limit(batchSize)
-                    );
-                }
-
-                let mustsReRun = true;
-                let useDocs: QueryDocumentSnapshot<RxDocType>[] = [];
-                while (mustsReRun) {
-                    /**
-                     * Local writes that have not been persisted to the server
-                     * are in pending state and do not have a correct serverTimestamp set.
-                     * We have to ensure we only use document states that are in sync with the server.
-                     * @link https://medium.com/firebase-developers/the-secrets-of-firestore-fieldvalue-servertimestamp-revealed-29dd7a38a82b
-                     */
-                    await waitForPendingWrites(options.firestore.database);
-                    await runTransaction(options.firestore.database, async (_tx) => {
-                        useDocs = [];
-                        const [
-                            newerQueryResult,
-                            sameTimeQueryResult
-                        ] = await Promise.all([
-                            getDocs(newerQuery),
-                            sameTimeQuery ? getDocs(sameTimeQuery) : undefined
-                        ]);
-
-                        if (
-                            newerQueryResult.metadata.hasPendingWrites ||
-                            (sameTimeQuery && ensureNotFalsy(sameTimeQueryResult).metadata.hasPendingWrites)
-                        ) {
-                            return;
-                        } else {
-                            mustsReRun = false;
-
-                            if (sameTimeQuery) {
-                                useDocs = ensureNotFalsy(sameTimeQueryResult).docs as any;
-                            }
-                            const missingAmount = batchSize - useDocs.length;
-                            if (missingAmount > 0) {
-                                const additionalDocs = newerQueryResult.docs.slice(0, missingAmount).filter(x => !!x);
-                                appendToArray(useDocs, additionalDocs);
-                            }
-                        }
-                    });
-                }
-
-                if (useDocs.length === 0) {
-                    return {
-                        checkpoint: lastPulledCheckpoint,
-                        documents: []
-                    };
-                }
-                const lastDoc = ensureNotFalsy(lastOfArray(useDocs));
-                const documents: WithDeleted<RxDocType>[] = useDocs
-                    .map(row => firestoreRowToDocData(
-                        serverTimestampField,
-                        primaryPath,
-                        row
-                    ));
-                const newCheckpoint: FirestoreCheckpointType = {
-                    id: lastDoc.id,
-                    serverTimestamp: serverTimestampToIsoString(serverTimestampField, lastDoc.data())
-                };
-                const ret = {
-                    documents: documents,
-                    checkpoint: newCheckpoint
-                };
-                return ret;
-            },
-            batchSize: ensureNotFalsy(options.pull).batchSize,
-            modifier: ensureNotFalsy(options.pull).modifier,
-            stream$: pullStream$.asObservable()
-        };
-    }
-
-    let replicationPrimitivesPush: ReplicationPushOptions<RxDocType> | undefined;
-    if (options.push) {
-        const pushFilter = options.push?.filter;
-        replicationPrimitivesPush = {
-            async handler(
-                rows: RxReplicationWriteToMasterRow<RxDocType>[]
-            ) {
-                if (pushFilter !== undefined) {
-                    rows = await asyncFilter(rows, (row) => pushFilter(row.newDocumentState));
-                }
-
-                const writeRowsById: ById<RxReplicationWriteToMasterRow<RxDocType>> = {};
-                const docIds: string[] = rows.map(row => {
-                    const docId = (row.newDocumentState as any)[primaryPath];
-                    writeRowsById[docId] = row;
-                    return docId;
-                });
-                await waitForPendingWrites(options.firestore.database);
-                let conflicts: WithDeleted<RxDocType>[] = [];
-
-                /**
-                 * Everything must run INSIDE of the transaction
-                 * because on tx-errors, firebase will re-run the transaction on some cases.
-                 * @link https://firebase.google.com/docs/firestore/manage-data/transactions#transaction_failure
-                 * @link https://firebase.google.com/docs/firestore/manage-data/transactions
-                 */
-                await runTransaction(options.firestore.database, async (_tx) => {
-                    conflicts = []; // reset in case the tx has re-run.
-                    /**
-                     * @link https://stackoverflow.com/a/48423626/3443137
-                     */
-
-                    const getQuery = (ids: string[]) => {
-                        return getDocs(
-                            query(
-                                options.firestore.collection,
-                                where(documentId(), 'in', ids)
-                            )
-                        );
-                    };
-
-                    const docsInDbResult = await getContentByIds<RxDocType>(docIds, getQuery);
-
-                    const docsInDbById: ById<RxDocType> = {};
-                    docsInDbResult.forEach(row => {
-                        const docDataInDb = stripServerTimestampField(serverTimestampField, row.data());
-                        const docId = row.id;
-                        (docDataInDb as any)[primaryPath] = docId;
-                        docsInDbById[docId] = docDataInDb;
-                    });
-
-                    /**
-                     * @link https://firebase.google.com/docs/firestore/manage-data/transactions#batched-writes
-                     */
-                    const batch = writeBatch(options.firestore.database);
-                    let hasWrite = false;
-                    await Promise.all(
-                        Object.entries(writeRowsById).map(async ([docId, writeRow]) => {
-                            const docInDb: RxDocType | undefined = docsInDbById[docId];
-
-                            if (
-                                docInDb &&
-                                (
-                                    !writeRow.assumedMasterState ||
-                                    (await collection.conflictHandler({
-                                        newDocumentState: docInDb as any,
-                                        realMasterState: writeRow.assumedMasterState
-                                    }, 'replication-firestore-push')).isEqual === false
-                                )
-                            ) {
-                                // conflict
-                                conflicts.push(docInDb as any);
-                            } else {
-                                // no conflict
-                                hasWrite = true;
-                                const docRef = doc(options.firestore.collection, docId);
-                                const writeDocData = flatClone(writeRow.newDocumentState);
-                                (writeDocData as any)[serverTimestampField] = serverTimestamp();
-                                if (!docInDb) {
-                                    // insert
-                                    batch.set(docRef, stripPrimaryKey(primaryPath, writeDocData));
-                                } else {
-                                    // update
-                                    batch.update(docRef, stripPrimaryKey(primaryPath, writeDocData));
-                                }
-                            }
-                        })
-                    );
-
-                    if (hasWrite) {
-                        await batch.commit();
-                    }
-                });
-                await waitForPendingWrites(options.firestore.database);
-                return conflicts;
-            },
-            batchSize: options.push.batchSize,
-            modifier: options.push.modifier
-        };
-    }
-
-
-    const replicationState = new RxFirestoreReplicationState<RxDocType>(
-        options.firestore,
-        FIRESTORE_REPLICATION_PLUGIN_IDENTITY_PREFIX + options.collection.database.hashFunction(options.firestore.projectId),
-        collection,
-        replicationPrimitivesPull,
-        replicationPrimitivesPush,
-        options.live,
-        options.retryTime,
-        options.autoStart
-    );
-
-    /**
-     * Use long polling to get live changes for the pull.stream$
-     */
-    if (options.live && options.pull) {
-        const startBefore = replicationState.start.bind(replicationState);
-        const cancelBefore = replicationState.cancel.bind(replicationState);
-        replicationState.start = () => {
-            const lastChangeQuery = query(
-                pullQuery,
-                orderBy(serverTimestampField, 'desc'),
-                limit(1)
-            );
-            const unsubscribe = onSnapshot(
-                lastChangeQuery,
-                (_querySnapshot) => {
-                    /**
-                     * There is no good way to observe the event stream in firestore.
-                     * So instead we listen to any write to the collection
-                     * and then emit a 'RESYNC' flag.
-                     */
-                    replicationState.reSync();
-                },
-                (error) => {
-                    replicationState.subjects.error.next(
-                        newRxError('RC_STREAM', { error: errorToPlainJson(error) })
-                    );
-                }
-            );
-            replicationState.cancel = () => {
-                unsubscribe();
-                return cancelBefore();
-            };
-            return startBefore();
-        };
-    }
-
-    startReplicationOnLeaderShip(options.waitForLeadership, replicationState);
-
-    return replicationState;
-}
diff --git a/node_modules/rxdb/package.json b/node_modules/rxdb/package.json
index ebda2db..e4db81d 100644
--- a/node_modules/rxdb/package.json
+++ b/node_modules/rxdb/package.json
@@ -1,591 +1,571 @@
 {
-  "name": "rxdb",
-  "description": "A local-first realtime NoSQL Database for JavaScript applications - https://rxdb.info/",
-  "version": "14.17.1",
-  "author": "pubkey",
-  "repository": {
-    "type": "git",
-    "url": "https://github.com/pubkey/rxdb"
-  },
-  "homepage": "https://rxdb.info/",
-  "keywords": [
-    "db",
-    "database",
-    "offline-first",
-    "local-first",
-    "nosql",
-    "no-sql",
-    "jsonschema",
-    "schema",
-    "rxjs",
-    "pwa",
-    "progessive web app",
-    "hybrid app",
-    "localstorage",
-    "indexeddb",
-    "storage",
-    "react-native",
-    "encryption",
-    "encrypted",
-    "firestore",
-    "firebase",
-    "couchdb",
-    "pouchdb",
-    "nats",
-    "websql",
-    "sqlite",
-    "query",
-    "live-query",
-    "realtime query",
-    "reactive",
-    "replication",
-    "realtime",
-    "realtime database",
-    "local database",
-    "embedded database",
-    "in-memory",
-    "memory",
-    "memory database",
-    "local database",
-    "embedded",
-    "embed",
-    "electron database",
-    "mongodb",
-    "lokijs",
-    "JSON",
-    "angular database",
-    "react database",
-    "capacitor database",
-    "node.js database",
-    "document",
-    "file database",
-    "json database",
-    "key value database",
-    "database driver",
-    "database abstraction layer",
-    "document database",
-    "graph database",
-    "mock database",
-    "cross-database",
-    "asyncstorage",
-    "localforage",
-    "mongoose",
-    "migrate database",
-    "websocket database",
-    "database-client",
-    "dbms",
-    "database engine",
-    "datastore"
-  ],
-  "license": "Apache-2.0",
-  "main": "./dist/lib/index.js",
-  "jsnext:main": "./dist/es/index.js",
-  "module": "./dist/es/index.js",
-  "types": "./dist/types/index.d.ts",
-  "sideEffects": false,
-  "exports": {
-    ".": {
-      "types": "./dist/types/index.d.ts",
-      "node": "./dist/lib/index.js",
-      "require": "./dist/lib/index.js",
-      "es2015": "./dist/es/index.js",
-      "default": "./dist/es/index.js"
-    },
-    "./plugins/core": {
-      "types": "./dist/types/core/index.d.ts",
-      "node": "./dist/lib/core/index.js",
-      "require": "./dist/lib/core/index.js",
-      "es2015": "./dist/es/core/index.js",
-      "default": "./dist/es/core/index.js"
-    },
-    "./plugins/utils": {
-      "types": "./dist/types/plugins/utils/index.d.ts",
-      "node": "./dist/lib/plugins/utils/index.js",
-      "require": "./dist/lib/plugins/utils/index.js",
-      "es2015": "./dist/es/plugins/utils/index.js",
-      "default": "./dist/es/plugins/utils/index.js"
-    },
-    "./plugins/backup": {
-      "types": "./dist/types/plugins/backup/index.d.ts",
-      "node": "./dist/lib/plugins/backup/index.js",
-      "require": "./dist/lib/plugins/backup/index.js",
-      "es2015": "./dist/es/plugins/backup/index.js",
-      "default": "./dist/es/plugins/backup/index.js"
-    },
-    "./plugins/cleanup": {
-      "types": "./dist/types/plugins/cleanup/index.d.ts",
-      "node": "./dist/lib/plugins/cleanup/index.js",
-      "require": "./dist/lib/plugins/cleanup/index.js",
-      "es2015": "./dist/es/plugins/cleanup/index.js",
-      "default": "./dist/es/plugins/cleanup/index.js"
-    },
-    "./plugins/crdt": {
-      "types": "./dist/types/plugins/crdt/index.d.ts",
-      "node": "./dist/lib/plugins/crdt/index.js",
-      "require": "./dist/lib/plugins/crdt/index.js",
-      "es2015": "./dist/es/plugins/crdt/index.js",
-      "default": "./dist/es/plugins/crdt/index.js"
-    },
-    "./plugins/dev-mode": {
-      "types": "./dist/types/plugins/dev-mode/index.d.ts",
-      "node": "./dist/lib/plugins/dev-mode/index.js",
-      "require": "./dist/lib/plugins/dev-mode/index.js",
-      "es2015": "./dist/es/plugins/dev-mode/index.js",
-      "default": "./dist/es/plugins/dev-mode/index.js"
-    },
-    "./plugins/storage-dexie": {
-      "types": "./dist/types/plugins/storage-dexie/index.d.ts",
-      "node": "./dist/lib/plugins/storage-dexie/index.js",
-      "require": "./dist/lib/plugins/storage-dexie/index.js",
-      "es2015": "./dist/es/plugins/storage-dexie/index.js",
-      "default": "./dist/es/plugins/storage-dexie/index.js"
-    },
-    "./plugins/electron": {
-      "types": "./dist/types/plugins/electron/index.d.ts",
-      "node": "./dist/lib/plugins/electron/index.js",
-      "require": "./dist/lib/plugins/electron/index.js",
-      "es2015": "./dist/es/plugins/electron/index.js",
-      "default": "./dist/es/plugins/electron/index.js"
-    },
-    "./plugins/flutter": {
-      "types": "./dist/types/plugins/flutter/index.d.ts",
-      "node": "./dist/lib/plugins/flutter/index.js",
-      "require": "./dist/lib/plugins/flutter/index.js",
-      "es2015": "./dist/es/plugins/flutter/index.js",
-      "default": "./dist/es/plugins/flutter/index.js"
-    },
-    "./plugins/storage-foundationdb": {
-      "types": "./dist/types/plugins/storage-foundationdb/index.d.ts",
-      "node": "./dist/lib/plugins/storage-foundationdb/index.js",
-      "require": "./dist/lib/plugins/storage-foundationdb/index.js",
-      "es2015": "./dist/es/plugins/storage-foundationdb/index.js",
-      "default": "./dist/es/plugins/storage-foundationdb/index.js"
-    },
-    "./plugins/local-documents": {
-      "types": "./dist/types/plugins/local-documents/index.d.ts",
-      "node": "./dist/lib/plugins/local-documents/index.js",
-      "require": "./dist/lib/plugins/local-documents/index.js",
-      "es2015": "./dist/es/plugins/local-documents/index.js",
-      "default": "./dist/es/plugins/local-documents/index.js"
-    },
-    "./plugins/storage-lokijs": {
-      "types": "./dist/types/plugins/storage-lokijs/index.d.ts",
-      "node": "./dist/lib/plugins/storage-lokijs/index.js",
-      "require": "./dist/lib/plugins/storage-lokijs/index.js",
-      "es2015": "./dist/es/plugins/storage-lokijs/index.js",
-      "default": "./dist/es/plugins/storage-lokijs/index.js"
-    },
-    "./plugins/storage-memory": {
-      "types": "./dist/types/plugins/storage-memory/index.d.ts",
-      "node": "./dist/lib/plugins/storage-memory/index.js",
-      "require": "./dist/lib/plugins/storage-memory/index.js",
-      "es2015": "./dist/es/plugins/storage-memory/index.js",
-      "default": "./dist/es/plugins/storage-memory/index.js"
-    },
-    "./plugins/storage-mongodb": {
-      "types": "./dist/types/plugins/storage-mongodb/index.d.ts",
-      "node": "./dist/lib/plugins/storage-mongodb/index.js",
-      "require": "./dist/lib/plugins/storage-mongodb/index.js",
-      "es2015": "./dist/es/plugins/storage-mongodb/index.js",
-      "default": "./dist/es/plugins/storage-mongodb/index.js"
-    },
-    "./plugins/migration": {
-      "types": "./dist/types/plugins/migration/index.d.ts",
-      "node": "./dist/lib/plugins/migration/index.js",
-      "require": "./dist/lib/plugins/migration/index.js",
-      "es2015": "./dist/es/plugins/migration/index.js",
-      "default": "./dist/es/plugins/migration/index.js"
-    },
-    "./plugins/query-builder": {
-      "types": "./dist/types/plugins/query-builder/index.d.ts",
-      "node": "./dist/lib/plugins/query-builder/index.js",
-      "require": "./dist/lib/plugins/query-builder/index.js",
-      "es2015": "./dist/es/plugins/query-builder/index.js",
-      "default": "./dist/es/plugins/query-builder/index.js"
-    },
-    "./plugins/replication": {
-      "types": "./dist/types/plugins/replication/index.d.ts",
-      "node": "./dist/lib/plugins/replication/index.js",
-      "require": "./dist/lib/plugins/replication/index.js",
-      "es2015": "./dist/es/plugins/replication/index.js",
-      "default": "./dist/es/plugins/replication/index.js"
-    },
-    "./plugins/replication-firestore": {
-      "types": "./dist/types/plugins/replication-firestore/index.d.ts",
-      "node": "./dist/lib/plugins/replication-firestore/index.js",
-      "require": "./dist/lib/plugins/replication-firestore/index.js",
-      "es2015": "./dist/es/plugins/replication-firestore/index.js",
-      "default": "./dist/es/plugins/replication-firestore/index.js"
-    },
-    "./plugins/replication-graphql": {
-      "types": "./dist/types/plugins/replication-graphql/index.d.ts",
-      "node": "./dist/lib/plugins/replication-graphql/index.js",
-      "require": "./dist/lib/plugins/replication-graphql/index.js",
-      "es2015": "./dist/es/plugins/replication-graphql/index.js",
-      "default": "./dist/es/plugins/replication-graphql/index.js"
-    },
-    "./plugins/replication-p2p": {
-      "types": "./dist/types/plugins/replication-p2p/index.d.ts",
-      "node": "./dist/lib/plugins/replication-p2p/index.js",
-      "require": "./dist/lib/plugins/replication-p2p/index.js",
-      "es2015": "./dist/es/plugins/replication-p2p/index.js",
-      "default": "./dist/es/plugins/replication-p2p/index.js"
-    },
-    "./plugins/replication-websocket": {
-      "types": "./dist/types/plugins/replication-websocket/index.d.ts",
-      "node": "./dist/lib/plugins/replication-websocket/index.js",
-      "require": "./dist/lib/plugins/replication-websocket/index.js",
-      "es2015": "./dist/es/plugins/replication-websocket/index.js",
-      "default": "./dist/es/plugins/replication-websocket/index.js"
-    },
-    "./plugins/storage-remote": {
-      "types": "./dist/types/plugins/storage-remote/index.d.ts",
-      "node": "./dist/lib/plugins/storage-remote/index.js",
-      "require": "./dist/lib/plugins/storage-remote/index.js",
-      "es2015": "./dist/es/plugins/storage-remote/index.js",
-      "default": "./dist/es/plugins/storage-remote/index.js"
-    },
-    "./plugins/storage-remote-websocket": {
-      "types": "./dist/types/plugins/storage-remote-websocket/index.d.ts",
-      "node": "./dist/lib/plugins/storage-remote-websocket/index.js",
-      "require": "./dist/lib/plugins/storage-remote-websocket/index.js",
-      "es2015": "./dist/es/plugins/storage-remote-websocket/index.js",
-      "default": "./dist/es/plugins/storage-remote-websocket/index.js"
-    },
-    "./plugins/attachments": {
-      "types": "./dist/types/plugins/attachments/index.d.ts",
-      "node": "./dist/lib/plugins/attachments/index.js",
-      "require": "./dist/lib/plugins/attachments/index.js",
-      "es2015": "./dist/es/plugins/attachments/index.js",
-      "default": "./dist/es/plugins/attachments/index.js"
-    },
-    "./plugins/attachments-compression": {
-      "types": "./dist/types/plugins/attachments-compression/index.d.ts",
-      "node": "./dist/lib/plugins/attachments-compression/index.js",
-      "require": "./dist/lib/plugins/attachments-compression/index.js",
-      "es2015": "./dist/es/plugins/attachments-compression/index.js",
-      "default": "./dist/es/plugins/attachments-compression/index.js"
-    },
-    "./plugins/encryption-crypto-js": {
-      "types": "./dist/types/plugins/encryption-crypto-js/index.d.ts",
-      "node": "./dist/lib/plugins/encryption-crypto-js/index.js",
-      "require": "./dist/lib/plugins/encryption-crypto-js/index.js",
-      "es2015": "./dist/es/plugins/encryption-crypto-js/index.js",
-      "default": "./dist/es/plugins/encryption-crypto-js/index.js"
-    },
-    "./plugins/json-dump": {
-      "types": "./dist/types/plugins/json-dump/index.d.ts",
-      "node": "./dist/lib/plugins/json-dump/index.js",
-      "require": "./dist/lib/plugins/json-dump/index.js",
-      "es2015": "./dist/es/plugins/json-dump/index.js",
-      "default": "./dist/es/plugins/json-dump/index.js"
-    },
-    "./plugins/key-compression": {
-      "types": "./dist/types/plugins/key-compression/index.d.ts",
-      "node": "./dist/lib/plugins/key-compression/index.js",
-      "require": "./dist/lib/plugins/key-compression/index.js",
-      "es2015": "./dist/es/plugins/key-compression/index.js",
-      "default": "./dist/es/plugins/key-compression/index.js"
-    },
-    "./plugins/leader-election": {
-      "types": "./dist/types/plugins/leader-election/index.d.ts",
-      "node": "./dist/lib/plugins/leader-election/index.js",
-      "require": "./dist/lib/plugins/leader-election/index.js",
-      "es2015": "./dist/es/plugins/leader-election/index.js",
-      "default": "./dist/es/plugins/leader-election/index.js"
-    },
-    "./plugins/replication-couchdb": {
-      "types": "./dist/types/plugins/replication-couchdb/index.d.ts",
-      "node": "./dist/lib/plugins/replication-couchdb/index.js",
-      "require": "./dist/lib/plugins/replication-couchdb/index.js",
-      "es2015": "./dist/es/plugins/replication-couchdb/index.js",
-      "default": "./dist/es/plugins/replication-couchdb/index.js"
-    },
-    "./plugins/replication-nats": {
-      "types": "./dist/types/plugins/replication-nats/index.d.ts",
-      "node": "./dist/lib/plugins/replication-nats/index.js",
-      "require": "./dist/lib/plugins/replication-nats/index.js",
-      "es2015": "./dist/es/plugins/replication-nats/index.js",
-      "default": "./dist/es/plugins/replication-nats/index.js"
-    },
-    "./plugins/update": {
-      "types": "./dist/types/plugins/update/index.d.ts",
-      "node": "./dist/lib/plugins/update/index.js",
-      "require": "./dist/lib/plugins/update/index.js",
-      "es2015": "./dist/es/plugins/update/index.js",
-      "default": "./dist/es/plugins/update/index.js"
-    },
-    "./plugins/validate-ajv": {
-      "types": "./dist/types/plugins/validate-ajv/index.d.ts",
-      "node": "./dist/lib/plugins/validate-ajv/index.js",
-      "require": "./dist/lib/plugins/validate-ajv/index.js",
-      "es2015": "./dist/es/plugins/validate-ajv/index.js",
-      "default": "./dist/es/plugins/validate-ajv/index.js"
-    },
-    "./plugins/validate-is-my-json-valid": {
-      "types": "./dist/types/plugins/validate-is-my-json-valid/index.d.ts",
-      "node": "./dist/lib/plugins/validate-is-my-json-valid/index.js",
-      "require": "./dist/lib/plugins/validate-is-my-json-valid/index.js",
-      "es2015": "./dist/es/plugins/validate-is-my-json-valid/index.js",
-      "default": "./dist/es/plugins/validate-is-my-json-valid/index.js"
-    },
-    "./plugins/validate-z-schema": {
-      "types": "./dist/types/plugins/validate-z-schema/index.d.ts",
-      "node": "./dist/lib/plugins/validate-z-schema/index.js",
-      "require": "./dist/lib/plugins/validate-z-schema/index.js",
-      "es2015": "./dist/es/plugins/validate-z-schema/index.js",
-      "default": "./dist/es/plugins/validate-z-schema/index.js"
-    },
-    "./package.json": "./package.json"
-  },
-  "scripts": {
-    "postinstall": "node scripts/postinstall.js || echo \"ignore\"",
-    "test": "npm run test:node && npm run test:browser",
-    "// test:fast": "run tests in the fast-mode. Most of them will run in parrallel, skips tests that are known slow",
-    "test:fast": "npm run test:fast:memory && npm run test:fast:lokijs && npm run test:fast:dexie",
-    "test:fast:memory": "npm run transpile && cross-env DEFAULT_STORAGE=memory NODE_ENV=fast mocha --config ./config/.mocharc.js ./test_tmp/unit.test.js",
-    "test:fast:memory-validation": "npm run transpile && cross-env DEFAULT_STORAGE=memory-validation NODE_ENV=fast mocha --config ./config/.mocharc.js ./test_tmp/unit.test.js",
-    "test:fast:lokijs": "npm run transpile && cross-env DEFAULT_STORAGE=lokijs NODE_ENV=fast mocha --config ./config/.mocharc.js ./test_tmp/unit.test.js",
-    "test:fast:dexie": "npm run transpile && cross-env DEFAULT_STORAGE=dexie NODE_ENV=fast mocha --config ./config/.mocharc.js ./test_tmp/unit.test.js",
-    "test:fast:foundationdb": "npm run transpile && cross-env DEFAULT_STORAGE=foundationdb NODE_ENV=fast mocha --config ./config/.mocharc.js ./test_tmp/unit.test.js",
-    "test:fast:mongodb": "npm run transpile && cross-env DEFAULT_STORAGE=mongodb NODE_ENV=fast mocha --config ./config/.mocharc.js ./test_tmp/unit.test.js",
-    "// test:fast:loop": "runs tests in the fast-mode in a loop. Use this to debug tests that only fail sometimes",
-    "test:fast:loop": "npm run test:fast && npm run test:fast:loop",
-    "test:fast:loop:lokijs": "npm run test:fast:lokijs && npm run test:fast:loop:lokijs",
-    "test:fast:loop:memory": "npm run test:fast:memory && npm run test:fast:loop:memory",
-    "test:fast:loop:dexie": "npm run test:fast:dexie && npm run test:fast:loop:dexie",
-    "test:fast:loop:mongodb": "npm run test:fast:mongodb && npm run test:fast:loop:mongodb",
-    "test:node": "npm run test:node:lokijs && npm run test:node:dexie",
-    "test:node:memory": "npm run transpile && cross-env DEFAULT_STORAGE=memory mocha --expose-gc --config ./config/.mocharc.js ./test_tmp/unit.test.js",
-    "test:node:memory-validation": "npm run transpile && cross-env DEFAULT_STORAGE=memory-validation mocha --expose-gc --config ./config/.mocharc.js ./test_tmp/unit.test.js",
-    "test:node:lokijs": "npm run transpile && cross-env DEFAULT_STORAGE=lokijs mocha --expose-gc --config ./config/.mocharc.js ./test_tmp/unit.test.js",
-    "test:node:dexie": "npm run transpile && cross-env DEFAULT_STORAGE=dexie mocha --expose-gc --config ./config/.mocharc.js ./test_tmp/unit.test.js",
-    "test:bun:dexie": "npm run transpile && cross-env DEFAULT_STORAGE=dexie NODE_ENV=fast bun run ./node_modules/mocha/bin/mocha test_tmp/unit.test.js --bail",
-    "test:node:foundationdb": "npm run transpile && cross-env DEFAULT_STORAGE=foundationdb mocha --expose-gc --config ./config/.mocharc.js ./test_tmp/unit.test.js",
-    "test:node:mongodb": "npm run transpile && cross-env DEFAULT_STORAGE=mongodb mocha --expose-gc --config ./config/.mocharc.js ./test_tmp/unit.test.js",
-    "test:node:remote": "npm run transpile && cross-env DEFAULT_STORAGE=remote mocha --expose-gc --config ./config/.mocharc.js ./test_tmp/unit.test.js",
-    "test:node:lokijs:loop": "npm run test:node:lokijs && npm run test:node:lokijs:loop",
-    "test:node:memory:loop": "npm run test:node:memory && npm run test:node:memory:loop",
-    "test:node:dexie:loop": "npm run test:node:dexie && npm run test:node:dexie:loop",
-    "test:node:foundationdb:loop": "npm run test:node:foundationdb && npm run test:node:foundationdb:loop",
-    "test:node:custom": "npm run transpile && cross-env DEFAULT_STORAGE=custom mocha --expose-gc --config ./config/.mocharc.js ./test_tmp/unit.test.js",
-    "// test:node:loop": "runs tests in node in a loop. Use this to debug tests that only fail sometimes",
-    "test:node:loop": "npm run test:node && npm run test:node:loop",
-    "test:browser:loop": "npm run test:browser && npm run test:browser:loop",
-    "test:browser:lokijs": " npm run transpile && cross-env CI=true DEFAULT_STORAGE=lokijs  karma start ./config/karma.conf.js --single-run",
-    "test:browser:memory": " npm run transpile && cross-env CI=true DEFAULT_STORAGE=memory  karma start ./config/karma.conf.js --single-run",
-    "test:browser:dexie": "  npm run transpile && cross-env CI=true DEFAULT_STORAGE=dexie   karma start ./config/karma.conf.js --single-run",
-    "test:browser:remote": "  npm run transpile && cross-env CI=true DEFAULT_STORAGE=remote karma start ./config/karma.conf.js --single-run",
-    "test:browser:custom": " npm run transpile && cross-env CI=true DEFAULT_STORAGE=custom  karma start ./config/karma.conf.js --single-run",
-    "test:replication-firestore": "npm run transpile && firebase emulators:exec \"cross-env DEFAULT_STORAGE=dexie mocha --expose-gc --config ./config/.mocharc.js ./test_tmp/replication-firestore.test.js\" --only firestore --project 'rxdb-test'",
-    "test:replication-couchdb": "npm run transpile && concurrently \"npm run couch:start\" \"cross-env NATIVE_COUCHDB=5984 DEFAULT_STORAGE=dexie mocha --config ./config/.mocharc.js ./test_tmp/unit/replication-couchdb.test.js\" --success first --kill-others",
-    "test:replication-nats": "npm run transpile && concurrently \"npm run nats:start\" \"cross-env DEFAULT_STORAGE=dexie mocha --config ./config/.mocharc.js ./test_tmp/replication-nats.test.js\" --success first --kill-others",
-    "test:core": "npm run transpile && mocha ./test_tmp/unit/core.node.js",
-    "test:full": "npm run transpile && mocha ./test_tmp/unit/full.node.js",
-    "test:typings": "tsc --noEmit --lib \"ES2021,DOM\" ./test/typings.test.ts",
-    "test:deps": "npm run build && dependency-check ./package.json ./dist/lib/index.js ./dist/lib/plugins/validate-is-my-json-valid/index.js ./dist/lib/plugins/attachments-compression/index.js ./dist/lib/plugins/validate-ajv/index.js ./dist/lib/plugins/update/index.js ./dist/lib/plugins/key-compression/index.js ./dist/lib/plugins/dev-mode/index.js ./dist/lib/plugins/encryption-crypto-js/index.js ./dist/lib/plugins/replication-graphql/index.js ./dist/lib/plugins/replication-p2p/index.js ./dist/lib/plugins/replication-websocket/index.js ./dist/lib/plugins/replication-firestore/index.js ./dist/lib/plugins/replication-nats/index.js ./dist/lib/plugins/validate-z-schema/index.js ./dist/lib/plugins/storage-lokijs/index.js ./dist/lib/plugins/storage-dexie/index.js ./dist/lib/plugins/storage-memory/index.js ./dist/lib/plugins/storage-mongodb/index.js --no-dev --ignore-module util --ignore-module url --ignore-module ws --ignore-module graphql --ignore-module as-typed --ignore-module \"@types/*\"",
-    "test:circular": "npm run build && madge --circular ./dist/es/index.js && madge --circular ./dist/es/plugins/storage-dexie/index.js",
-    "test:performance:lokijs:browser": "npm run transpile && cross-env DEFAULT_STORAGE=lokijs CI=true karma start ./config/karma.performance.conf.js --single-run",
-    "test:performance:lokijs:node": "npm run transpile && cross-env DEFAULT_STORAGE=lokijs mocha --config ./config/.mocharc.js ./test_tmp/performance.test.js --unhandled-rejections=strict --expose-gc",
-    "test:performance:dexie": "npm run transpile && cross-env DEFAULT_STORAGE=dexie CI=true karma start ./config/karma.performance.conf.js --single-run",
-    "test:performance:memory:browser": "npm run transpile && cross-env DEFAULT_STORAGE=memory CI=true karma start ./config/karma.performance.conf.js --single-run",
-    "test:performance:memory:node": "npm run transpile && cross-env DEFAULT_STORAGE=memory mocha --config ./config/.mocharc.js ./test_tmp/performance.test.js --unhandled-rejections=strict --expose-gc",
-    "test:performance:memory:bun": "npm run transpile && cross-env DEFAULT_STORAGE=memory bun run ./node_modules/mocha/bin/mocha test_tmp/performance.test.js --bail",
-    "test:performance:foundationdb": "npm run transpile && cross-env DEFAULT_STORAGE=foundationdb mocha --config ./config/.mocharc.js ./test_tmp/performance.test.js --unhandled-rejections=strict --expose-gc",
-    "test:performance:mongodb": "npm run transpile && cross-env DEFAULT_STORAGE=mongodb mocha --config ./config/.mocharc.js ./test_tmp/performance.test.js --unhandled-rejections=strict --expose-gc",
-    "test:performance:custom:browser": "npm run transpile && cross-env DEFAULT_STORAGE=custom CI=true karma start ./config/karma.performance.conf.js --single-run",
-    "test:performance:custom:node": "npm run transpile && cross-env DEFAULT_STORAGE=custom mocha --config ./config/.mocharc.js ./test_tmp/performance.test.js --unhandled-rejections=strict --expose-gc",
-    "test:performance": "npm run build && npm run test:performance:lokijs:browser && npm run test:performance:lokijs:node && npm run test:performance:dexie && npm run test:performance:memory:browser && npm run test:performance:memory:node && npm run test:performance:foundationdb",
-    "couch:start": "docker run -p 5984:5984 -e COUCHDB_USER=root -e COUCHDB_PASSWORD=root --rm --name rxdb-couchdb couchdb:3.3.1",
-    "couch:stop": "docker rm -f rxdb-couchdb",
-    "mongodb:start": "docker run -p 27017:27017 -p 27018:27018 -p 27019:27019 --rm --name rxdb-mongodb mongo:7.0.1",
-    "mongodb:stop": "docker rm -f rxdb-mongodb",
-    "nats:start": "docker run --rm --name rxdb-nats -p 4222:4222 nats:2.9.17 -js",
-    "nats:stop": "docker rm -f rxdb-nats",
-    "dockertest": "docker run -it -v $(pwd):/usr/src/app markadams/chromium-xvfb-js:latest-onbuild",
-    "profile": "npm run transpile && rm -f isolate-* && cross-env STORAGE=memory NODE_ENV=fast NODE_PROF=true mocha --config ./config/.mocharc.js ./test_tmp/performance.test.js --v8-prof --expose-gc && node scripts/profile.js",
-    "clear": "rimraf -rf test_tmp/ && rimraf -rf dist/ && rimraf .transpile_state.json",
-    "lint": "eslint . --ext .js,.ts --cache",
-    "lint:fix": "eslint --fix . --ext .js,.ts",
-    "lint:debug:files": "DEBUG=eslint:cli-engine eslint --ext .js,.ts,.json .",
-    "lint:debug:time": "TIMING=1 eslint --ext .js,.ts,.json .",
-    "check-types": "tsc",
-    "transpile": "npm run build:version && node scripts/transpile.js",
-    "build:version": "node ./scripts/update-version-variable.js",
-    "build:es": "npm run build:version && rimraf -rf --max-retries=3 dist/es && cross-env NODE_ENV=es6 babel src --out-dir dist/es --source-maps --extensions \".ts,.js\"",
-    "build:types": "npm run build:version && rimraf -rf --max-retries=3 ./dist/types && tsc --project ./config/tsconfig.types.json && cp -r ./src/types ./dist/types/types",
-    "build": "npm run clear && npm run build:version && concurrently \"npm run transpile\" \"npm run build:es\" \"npm run build:types\" \"npm run build:plugins\" && browserify dist/lib/browserify.index.js > dist/rxdb.browserify.js && terser --compress --mangle --output dist/rxdb.browserify.min.js -- dist/rxdb.browserify.js",
-    "build:plugins": "node ./scripts/generate-plugins-package-json.js",
-    "build:min": "npm run transpile && browserify dist/lib/browserify.index.js > dist/rxdb.browserify.js && terser --compress --mangle --output dist/rxdb.browserify.min.js -- dist/rxdb.browserify.js",
-    "build:webpack": "npm run build && cross-env NODE_ENV=build webpack --config ./config/webpack.config.js",
-    "build:rollup": "npm run build && rollup --config ./config/rollup.config.mjs",
-    "build:size": "npm run build:webpack && echo \"Build-Size (minified+gzip):\" && gzip-size --raw ./test_tmp/webpack.bundle.js",
-    "// docs": "TODO move away from gitbook so we are not forced to use node.js version 13 to build the docs",
-    "docs:install": "gitbook install docs-src",
-    "docs:landingpage:dev": "webpack-dev-server --mode development --config ./config/landingpage.webpack.config.js",
-    "docs:landingpage:build": "npm run build && webpack --config ./config/landingpage.webpack.config.js",
-    "docs:landingpage:copy": "rm -f ./docs/index.html && cp ./docs-src/index.html ./docs/index.html",
-    "// docs:serve": "start a local server to watch the docs. Served at http://localhost:4000/",
-    "docs:serve": "gitbook serve docs-src",
-    "docs:build": "gitbook install docs-src && gitbook build docs-src docs && cp docs-src/files/logo/icon.png docs/gitbook/images/apple-touch-icon-precomposed-152.png && cp docs-src/files/logo/icon.ico docs/gitbook/images/favicon.ico && npm run docs:copy && npm run docs:remove:time",
-    "docs:copy": "cp -r docs-src/files docs/files && npm run docs:landingpage:copy",
-    "docs:remove:time": "node ./scripts/docs-remove-time.js",
-    "disc": "npm run transpile && npm run build:es && cross-env NODE_ENV=disc webpack --config ./config/webpack.config.js",
-    "preversion": "npm run lint && npm run test",
-    "dev": "watch 'npm run test:node:memory' src/ test/",
-    "dev:example": "watch 'npm run transpile:src && echo \"done\"' src/ test/"
-  },
-  "pre-commit": [
-    "lint"
-  ],
-  "peerDependencies": {
-    "rxjs": "^7.8.0"
-  },
-  "dependencies": {
-    "@babel/runtime": "7.22.15",
-    "@types/clone": "2.1.2",
-    "@types/cors": "2.8.14",
-    "@types/express": "4.17.18",
-    "@types/lokijs": "1.5.10",
-    "@types/simple-peer": "9.11.5",
-    "@types/ws": "8.5.5",
-    "ajv": "8.12.0",
-    "array-push-at-sort-position": "3.0.0",
-    "as-typed": "1.3.2",
-    "broadcast-channel": "5.3.0",
-    "crypto-js": "4.1.1",
-    "custom-idle-queue": "3.0.1",
-    "dexie": "4.0.0-alpha.4",
-    "event-reduce-js": "3.1.2",
-    "firebase": "9.23.0",
-    "get-graphql-from-jsonschema": "8.1.0",
-    "graphql": "15.8.0",
-    "graphql-ws": "5.14.0",
-    "is-my-json-valid": "2.20.6",
-    "isomorphic-ws": "5.0.0",
-    "js-base64": "3.7.5",
-    "jsonschema-key-compression": "1.6.1",
-    "lokijs": "1.5.12",
-    "mingo": "6.4.4",
-    "modifyjs": "0.3.1",
-    "mongodb": "6.1.0",
-    "nats": "2.17.0",
-    "oblivious-set": "1.1.1",
-    "ohash": "1.1.3",
-    "pako": "2.1.0",
-    "reconnecting-websocket": "4.4.0",
-    "simple-peer": "9.11.1",
-    "socket.io-client": "4.7.2",
-    "unload": "2.4.1",
-    "util": "0.12.5",
-    "ws": "8.14.2",
-    "z-schema": "6.0.1"
-  },
-  "devDependencies": {
-    "@types/node": "18.17.19",
-    "@babel/cli": "7.22.15",
-    "@babel/core": "7.22.20",
-    "@babel/plugin-external-helpers": "7.22.5",
-    "@babel/plugin-proposal-class-properties": "7.18.6",
-    "@babel/plugin-proposal-object-rest-spread": "7.20.7",
-    "@babel/plugin-transform-literals": "7.22.5",
-    "@babel/plugin-transform-member-expression-literals": "7.22.5",
-    "@babel/plugin-transform-modules-commonjs": "7.22.15",
-    "@babel/plugin-transform-property-literals": "7.22.5",
-    "@babel/plugin-transform-runtime": "7.22.15",
-    "@babel/plugin-transform-spread": "7.22.5",
-    "@babel/plugin-transform-template-literals": "7.22.5",
-    "@babel/plugin-transform-typescript": "7.22.15",
-    "@babel/polyfill": "7.12.1",
-    "@babel/preset-env": "7.22.20",
-    "@babel/preset-typescript": "7.22.15",
-    "@babel/types": "7.22.19",
-    "@faker-js/faker": "7.6.0",
-    "@rollup/plugin-commonjs": "24.1.0",
-    "@rollup/plugin-node-resolve": "15.2.1",
-    "@types/assert": "1.5.7",
-    "@types/core-js": "2.5.6",
-    "@types/cors": "2.8.14",
-    "@types/crypto-js": "4.1.2",
-    "@types/mocha": "10.0.1",
-    "@types/pako": "2.0.1",
-    "@types/request": "2.48.8",
-    "@types/request-promise-native": "1.0.18",
-    "@typescript-eslint/eslint-plugin": "5.62.0",
-    "@typescript-eslint/parser": "5.62.0",
-    "assert": "2.1.0",
-    "async-test-util": "2.1.1",
-    "babel-loader": "9.1.3",
-    "babel-plugin-transform-class-properties": "6.24.1",
-    "brfs": "2.0.2",
-    "browserify": "17.0.0",
-    "child-process-promise": "2.2.1",
-    "clone": "2.1.2",
-    "concurrently": "8.2.1",
-    "copy-webpack-plugin": "11.0.0",
-    "cors": "2.8.5",
-    "cross-env": "7.0.3",
-    "delete": "1.1.0",
-    "dependency-check": "4.1.0",
-    "detect-browser": "5.3.0",
-    "disc": "1.3.3",
-    "eslint": "8.50.0",
-    "eslint-plugin-import": "2.28.1",
-    "eslint-plugin-jsdoc": "43.2.0",
-    "exists-file": "3.0.2",
-    "express": "4.18.2",
-    "express-graphql": "0.12.0",
-    "express-pouchdb": "4.2.0",
-    "fake-indexeddb": "4.0.2",
-    "firebase-tools": "11.30.0",
-    "get-port": "5.1.1",
-    "gitbook-cli": "2.3.2",
-    "graphql-subscriptions": "2.0.0",
-    "gzip-size-cli": "5.1.0",
-    "html-webpack-plugin": "5.5.3",
-    "karma": "6.4.2",
-    "karma-babel-preprocessor": "8.0.2",
-    "karma-chrome-launcher": "3.2.0",
-    "karma-coverage": "2.2.1",
-    "karma-detect-browsers": "2.3.3",
-    "karma-firefox-launcher": "2.1.2",
-    "karma-ie-launcher": "1.0.0",
-    "karma-mocha": "2.0.1",
-    "karma-opera-launcher": "1.0.0",
-    "karma-safari-launcher": "1.0.0",
-    "karma-sourcemap-loader": "0.4.0",
-    "karma-spec-reporter": "0.0.36",
-    "karma-webpack": "5.0.0",
-    "leveldown": "6.1.1",
-    "madge": "6.1.0",
-    "memdown": "6.1.1",
-    "mini-css-extract-plugin": "2.7.6",
-    "mocha": "10.2.0",
-    "mocha.parallel": "0.15.6",
-    "nconf": "0.12.0",
-    "node-pre-gyp": "0.17.0",
-    "pouchdb": "8.0.1",
-    "pre-commit": "1.2.2",
-    "random-int": "3.0.0",
-    "readline": "1.3.0",
-    "rimraf": "5.0.1",
-    "rollup": "3.29.2",
-    "rxjs": "7.8.1",
-    "shelljs": "0.8.5",
-    "socket.io": "4.7.2",
-    "source-map-support": "0.5.21",
-    "stream": "0.0.2",
-    "terser": "5.20.0",
-    "terser-webpack-plugin": "5.3.9",
-    "ts-loader": "9.4.4",
-    "ts-mocha": "10.0.0",
-    "ts-node": "10.9.1",
-    "typescript": "5.2.2",
-    "walk-sync": "3.0.0",
-    "watch": "1.0.2",
-    "webpack": "5.88.2",
-    "webpack-bundle-analyzer": "4.9.1",
-    "webpack-cli": "5.1.4",
-    "webpack-dev-server": "4.15.1"
-  }
+    "name": "rxdb",
+    "description": "A patched local-first realtime NoSQL Database for JavaScript applications - https://rxdb.info/",
+    "version": "14.17.1",
+    "author": "pubkey",
+    "repository": {
+        "type": "git",
+        "url": "https://github.com/pubkey/rxdb"
+    },
+    "homepage": "https://rxdb.info/",
+    "keywords": [
+        "db",
+        "database",
+        "offline-first",
+        "local-first",
+        "nosql",
+        "no-sql",
+        "jsonschema",
+        "schema",
+        "rxjs",
+        "pwa",
+        "progessive web app",
+        "hybrid app",
+        "localstorage",
+        "indexeddb",
+        "storage",
+        "react-native",
+        "encryption",
+        "encrypted",
+        "couchdb",
+        "pouchdb",
+        "nats",
+        "websql",
+        "sqlite",
+        "query",
+        "live-query",
+        "realtime query",
+        "reactive",
+        "replication",
+        "realtime",
+        "realtime database",
+        "local database",
+        "embedded database",
+        "in-memory",
+        "memory",
+        "memory database",
+        "local database",
+        "embedded",
+        "embed",
+        "electron database",
+        "mongodb",
+        "lokijs",
+        "JSON",
+        "angular database",
+        "react database",
+        "capacitor database",
+        "node.js database",
+        "document",
+        "file database",
+        "json database",
+        "key value database",
+        "database driver",
+        "database abstraction layer",
+        "document database",
+        "graph database",
+        "mock database",
+        "cross-database",
+        "asyncstorage",
+        "localforage",
+        "mongoose",
+        "migrate database",
+        "websocket database",
+        "database-client",
+        "dbms",
+        "database engine",
+        "datastore"
+    ],
+    "license": "Apache-2.0",
+    "main": "./dist/lib/index.js",
+    "jsnext:main": "./dist/es/index.js",
+    "module": "./dist/es/index.js",
+    "types": "./dist/types/index.d.ts",
+    "sideEffects": false,
+    "exports": {
+        ".": {
+            "types": "./dist/types/index.d.ts",
+            "node": "./dist/lib/index.js",
+            "require": "./dist/lib/index.js",
+            "es2015": "./dist/es/index.js",
+            "default": "./dist/es/index.js"
+        },
+        "./plugins/core": {
+            "types": "./dist/types/core/index.d.ts",
+            "node": "./dist/lib/core/index.js",
+            "require": "./dist/lib/core/index.js",
+            "es2015": "./dist/es/core/index.js",
+            "default": "./dist/es/core/index.js"
+        },
+        "./plugins/utils": {
+            "types": "./dist/types/plugins/utils/index.d.ts",
+            "node": "./dist/lib/plugins/utils/index.js",
+            "require": "./dist/lib/plugins/utils/index.js",
+            "es2015": "./dist/es/plugins/utils/index.js",
+            "default": "./dist/es/plugins/utils/index.js"
+        },
+        "./plugins/backup": {
+            "types": "./dist/types/plugins/backup/index.d.ts",
+            "node": "./dist/lib/plugins/backup/index.js",
+            "require": "./dist/lib/plugins/backup/index.js",
+            "es2015": "./dist/es/plugins/backup/index.js",
+            "default": "./dist/es/plugins/backup/index.js"
+        },
+        "./plugins/cleanup": {
+            "types": "./dist/types/plugins/cleanup/index.d.ts",
+            "node": "./dist/lib/plugins/cleanup/index.js",
+            "require": "./dist/lib/plugins/cleanup/index.js",
+            "es2015": "./dist/es/plugins/cleanup/index.js",
+            "default": "./dist/es/plugins/cleanup/index.js"
+        },
+        "./plugins/crdt": {
+            "types": "./dist/types/plugins/crdt/index.d.ts",
+            "node": "./dist/lib/plugins/crdt/index.js",
+            "require": "./dist/lib/plugins/crdt/index.js",
+            "es2015": "./dist/es/plugins/crdt/index.js",
+            "default": "./dist/es/plugins/crdt/index.js"
+        },
+        "./plugins/dev-mode": {
+            "types": "./dist/types/plugins/dev-mode/index.d.ts",
+            "node": "./dist/lib/plugins/dev-mode/index.js",
+            "require": "./dist/lib/plugins/dev-mode/index.js",
+            "es2015": "./dist/es/plugins/dev-mode/index.js",
+            "default": "./dist/es/plugins/dev-mode/index.js"
+        },
+        "./plugins/storage-dexie": {
+            "types": "./dist/types/plugins/storage-dexie/index.d.ts",
+            "node": "./dist/lib/plugins/storage-dexie/index.js",
+            "require": "./dist/lib/plugins/storage-dexie/index.js",
+            "es2015": "./dist/es/plugins/storage-dexie/index.js",
+            "default": "./dist/es/plugins/storage-dexie/index.js"
+        },
+        "./plugins/electron": {
+            "types": "./dist/types/plugins/electron/index.d.ts",
+            "node": "./dist/lib/plugins/electron/index.js",
+            "require": "./dist/lib/plugins/electron/index.js",
+            "es2015": "./dist/es/plugins/electron/index.js",
+            "default": "./dist/es/plugins/electron/index.js"
+        },
+        "./plugins/flutter": {
+            "types": "./dist/types/plugins/flutter/index.d.ts",
+            "node": "./dist/lib/plugins/flutter/index.js",
+            "require": "./dist/lib/plugins/flutter/index.js",
+            "es2015": "./dist/es/plugins/flutter/index.js",
+            "default": "./dist/es/plugins/flutter/index.js"
+        },
+        "./plugins/storage-foundationdb": {
+            "types": "./dist/types/plugins/storage-foundationdb/index.d.ts",
+            "node": "./dist/lib/plugins/storage-foundationdb/index.js",
+            "require": "./dist/lib/plugins/storage-foundationdb/index.js",
+            "es2015": "./dist/es/plugins/storage-foundationdb/index.js",
+            "default": "./dist/es/plugins/storage-foundationdb/index.js"
+        },
+        "./plugins/local-documents": {
+            "types": "./dist/types/plugins/local-documents/index.d.ts",
+            "node": "./dist/lib/plugins/local-documents/index.js",
+            "require": "./dist/lib/plugins/local-documents/index.js",
+            "es2015": "./dist/es/plugins/local-documents/index.js",
+            "default": "./dist/es/plugins/local-documents/index.js"
+        },
+        "./plugins/storage-lokijs": {
+            "types": "./dist/types/plugins/storage-lokijs/index.d.ts",
+            "node": "./dist/lib/plugins/storage-lokijs/index.js",
+            "require": "./dist/lib/plugins/storage-lokijs/index.js",
+            "es2015": "./dist/es/plugins/storage-lokijs/index.js",
+            "default": "./dist/es/plugins/storage-lokijs/index.js"
+        },
+        "./plugins/storage-memory": {
+            "types": "./dist/types/plugins/storage-memory/index.d.ts",
+            "node": "./dist/lib/plugins/storage-memory/index.js",
+            "require": "./dist/lib/plugins/storage-memory/index.js",
+            "es2015": "./dist/es/plugins/storage-memory/index.js",
+            "default": "./dist/es/plugins/storage-memory/index.js"
+        },
+        "./plugins/storage-mongodb": {
+            "types": "./dist/types/plugins/storage-mongodb/index.d.ts",
+            "node": "./dist/lib/plugins/storage-mongodb/index.js",
+            "require": "./dist/lib/plugins/storage-mongodb/index.js",
+            "es2015": "./dist/es/plugins/storage-mongodb/index.js",
+            "default": "./dist/es/plugins/storage-mongodb/index.js"
+        },
+        "./plugins/migration": {
+            "types": "./dist/types/plugins/migration/index.d.ts",
+            "node": "./dist/lib/plugins/migration/index.js",
+            "require": "./dist/lib/plugins/migration/index.js",
+            "es2015": "./dist/es/plugins/migration/index.js",
+            "default": "./dist/es/plugins/migration/index.js"
+        },
+        "./plugins/query-builder": {
+            "types": "./dist/types/plugins/query-builder/index.d.ts",
+            "node": "./dist/lib/plugins/query-builder/index.js",
+            "require": "./dist/lib/plugins/query-builder/index.js",
+            "es2015": "./dist/es/plugins/query-builder/index.js",
+            "default": "./dist/es/plugins/query-builder/index.js"
+        },
+        "./plugins/replication": {
+            "types": "./dist/types/plugins/replication/index.d.ts",
+            "node": "./dist/lib/plugins/replication/index.js",
+            "require": "./dist/lib/plugins/replication/index.js",
+            "es2015": "./dist/es/plugins/replication/index.js",
+            "default": "./dist/es/plugins/replication/index.js"
+        },
+        "./plugins/replication-graphql": {
+            "types": "./dist/types/plugins/replication-graphql/index.d.ts",
+            "node": "./dist/lib/plugins/replication-graphql/index.js",
+            "require": "./dist/lib/plugins/replication-graphql/index.js",
+            "es2015": "./dist/es/plugins/replication-graphql/index.js",
+            "default": "./dist/es/plugins/replication-graphql/index.js"
+        },
+        "./plugins/replication-p2p": {
+            "types": "./dist/types/plugins/replication-p2p/index.d.ts",
+            "node": "./dist/lib/plugins/replication-p2p/index.js",
+            "require": "./dist/lib/plugins/replication-p2p/index.js",
+            "es2015": "./dist/es/plugins/replication-p2p/index.js",
+            "default": "./dist/es/plugins/replication-p2p/index.js"
+        },
+        "./plugins/replication-websocket": {
+            "types": "./dist/types/plugins/replication-websocket/index.d.ts",
+            "node": "./dist/lib/plugins/replication-websocket/index.js",
+            "require": "./dist/lib/plugins/replication-websocket/index.js",
+            "es2015": "./dist/es/plugins/replication-websocket/index.js",
+            "default": "./dist/es/plugins/replication-websocket/index.js"
+        },
+        "./plugins/storage-remote": {
+            "types": "./dist/types/plugins/storage-remote/index.d.ts",
+            "node": "./dist/lib/plugins/storage-remote/index.js",
+            "require": "./dist/lib/plugins/storage-remote/index.js",
+            "es2015": "./dist/es/plugins/storage-remote/index.js",
+            "default": "./dist/es/plugins/storage-remote/index.js"
+        },
+        "./plugins/storage-remote-websocket": {
+            "types": "./dist/types/plugins/storage-remote-websocket/index.d.ts",
+            "node": "./dist/lib/plugins/storage-remote-websocket/index.js",
+            "require": "./dist/lib/plugins/storage-remote-websocket/index.js",
+            "es2015": "./dist/es/plugins/storage-remote-websocket/index.js",
+            "default": "./dist/es/plugins/storage-remote-websocket/index.js"
+        },
+        "./plugins/attachments": {
+            "types": "./dist/types/plugins/attachments/index.d.ts",
+            "node": "./dist/lib/plugins/attachments/index.js",
+            "require": "./dist/lib/plugins/attachments/index.js",
+            "es2015": "./dist/es/plugins/attachments/index.js",
+            "default": "./dist/es/plugins/attachments/index.js"
+        },
+        "./plugins/attachments-compression": {
+            "types": "./dist/types/plugins/attachments-compression/index.d.ts",
+            "node": "./dist/lib/plugins/attachments-compression/index.js",
+            "require": "./dist/lib/plugins/attachments-compression/index.js",
+            "es2015": "./dist/es/plugins/attachments-compression/index.js",
+            "default": "./dist/es/plugins/attachments-compression/index.js"
+        },
+        "./plugins/json-dump": {
+            "types": "./dist/types/plugins/json-dump/index.d.ts",
+            "node": "./dist/lib/plugins/json-dump/index.js",
+            "require": "./dist/lib/plugins/json-dump/index.js",
+            "es2015": "./dist/es/plugins/json-dump/index.js",
+            "default": "./dist/es/plugins/json-dump/index.js"
+        },
+        "./plugins/key-compression": {
+            "types": "./dist/types/plugins/key-compression/index.d.ts",
+            "node": "./dist/lib/plugins/key-compression/index.js",
+            "require": "./dist/lib/plugins/key-compression/index.js",
+            "es2015": "./dist/es/plugins/key-compression/index.js",
+            "default": "./dist/es/plugins/key-compression/index.js"
+        },
+        "./plugins/leader-election": {
+            "types": "./dist/types/plugins/leader-election/index.d.ts",
+            "node": "./dist/lib/plugins/leader-election/index.js",
+            "require": "./dist/lib/plugins/leader-election/index.js",
+            "es2015": "./dist/es/plugins/leader-election/index.js",
+            "default": "./dist/es/plugins/leader-election/index.js"
+        },
+        "./plugins/replication-couchdb": {
+            "types": "./dist/types/plugins/replication-couchdb/index.d.ts",
+            "node": "./dist/lib/plugins/replication-couchdb/index.js",
+            "require": "./dist/lib/plugins/replication-couchdb/index.js",
+            "es2015": "./dist/es/plugins/replication-couchdb/index.js",
+            "default": "./dist/es/plugins/replication-couchdb/index.js"
+        },
+        "./plugins/replication-nats": {
+            "types": "./dist/types/plugins/replication-nats/index.d.ts",
+            "node": "./dist/lib/plugins/replication-nats/index.js",
+            "require": "./dist/lib/plugins/replication-nats/index.js",
+            "es2015": "./dist/es/plugins/replication-nats/index.js",
+            "default": "./dist/es/plugins/replication-nats/index.js"
+        },
+        "./plugins/update": {
+            "types": "./dist/types/plugins/update/index.d.ts",
+            "node": "./dist/lib/plugins/update/index.js",
+            "require": "./dist/lib/plugins/update/index.js",
+            "es2015": "./dist/es/plugins/update/index.js",
+            "default": "./dist/es/plugins/update/index.js"
+        },
+        "./plugins/validate-ajv": {
+            "types": "./dist/types/plugins/validate-ajv/index.d.ts",
+            "node": "./dist/lib/plugins/validate-ajv/index.js",
+            "require": "./dist/lib/plugins/validate-ajv/index.js",
+            "es2015": "./dist/es/plugins/validate-ajv/index.js",
+            "default": "./dist/es/plugins/validate-ajv/index.js"
+        },
+        "./plugins/validate-is-my-json-valid": {
+            "types": "./dist/types/plugins/validate-is-my-json-valid/index.d.ts",
+            "node": "./dist/lib/plugins/validate-is-my-json-valid/index.js",
+            "require": "./dist/lib/plugins/validate-is-my-json-valid/index.js",
+            "es2015": "./dist/es/plugins/validate-is-my-json-valid/index.js",
+            "default": "./dist/es/plugins/validate-is-my-json-valid/index.js"
+        },
+        "./plugins/validate-z-schema": {
+            "types": "./dist/types/plugins/validate-z-schema/index.d.ts",
+            "node": "./dist/lib/plugins/validate-z-schema/index.js",
+            "require": "./dist/lib/plugins/validate-z-schema/index.js",
+            "es2015": "./dist/es/plugins/validate-z-schema/index.js",
+            "default": "./dist/es/plugins/validate-z-schema/index.js"
+        },
+        "./package.json": "./package.json"
+    },
+    "scripts": {
+        "postinstall": "node scripts/postinstall.js || echo \"ignore\"",
+        "test": "npm run test:node && npm run test:browser",
+        "// test:fast": "run tests in the fast-mode. Most of them will run in parrallel, skips tests that are known slow",
+        "test:fast": "npm run test:fast:memory && npm run test:fast:lokijs && npm run test:fast:dexie",
+        "test:fast:memory": "npm run transpile && cross-env DEFAULT_STORAGE=memory NODE_ENV=fast mocha --config ./config/.mocharc.js ./test_tmp/unit.test.js",
+        "test:fast:memory-validation": "npm run transpile && cross-env DEFAULT_STORAGE=memory-validation NODE_ENV=fast mocha --config ./config/.mocharc.js ./test_tmp/unit.test.js",
+        "test:fast:lokijs": "npm run transpile && cross-env DEFAULT_STORAGE=lokijs NODE_ENV=fast mocha --config ./config/.mocharc.js ./test_tmp/unit.test.js",
+        "test:fast:dexie": "npm run transpile && cross-env DEFAULT_STORAGE=dexie NODE_ENV=fast mocha --config ./config/.mocharc.js ./test_tmp/unit.test.js",
+        "test:fast:foundationdb": "npm run transpile && cross-env DEFAULT_STORAGE=foundationdb NODE_ENV=fast mocha --config ./config/.mocharc.js ./test_tmp/unit.test.js",
+        "test:fast:mongodb": "npm run transpile && cross-env DEFAULT_STORAGE=mongodb NODE_ENV=fast mocha --config ./config/.mocharc.js ./test_tmp/unit.test.js",
+        "// test:fast:loop": "runs tests in the fast-mode in a loop. Use this to debug tests that only fail sometimes",
+        "test:fast:loop": "npm run test:fast && npm run test:fast:loop",
+        "test:fast:loop:lokijs": "npm run test:fast:lokijs && npm run test:fast:loop:lokijs",
+        "test:fast:loop:memory": "npm run test:fast:memory && npm run test:fast:loop:memory",
+        "test:fast:loop:dexie": "npm run test:fast:dexie && npm run test:fast:loop:dexie",
+        "test:fast:loop:mongodb": "npm run test:fast:mongodb && npm run test:fast:loop:mongodb",
+        "test:node": "npm run test:node:lokijs && npm run test:node:dexie",
+        "test:node:memory": "npm run transpile && cross-env DEFAULT_STORAGE=memory mocha --expose-gc --config ./config/.mocharc.js ./test_tmp/unit.test.js",
+        "test:node:memory-validation": "npm run transpile && cross-env DEFAULT_STORAGE=memory-validation mocha --expose-gc --config ./config/.mocharc.js ./test_tmp/unit.test.js",
+        "test:node:lokijs": "npm run transpile && cross-env DEFAULT_STORAGE=lokijs mocha --expose-gc --config ./config/.mocharc.js ./test_tmp/unit.test.js",
+        "test:node:dexie": "npm run transpile && cross-env DEFAULT_STORAGE=dexie mocha --expose-gc --config ./config/.mocharc.js ./test_tmp/unit.test.js",
+        "test:bun:dexie": "npm run transpile && cross-env DEFAULT_STORAGE=dexie NODE_ENV=fast bun run ./node_modules/mocha/bin/mocha test_tmp/unit.test.js --bail",
+        "test:node:foundationdb": "npm run transpile && cross-env DEFAULT_STORAGE=foundationdb mocha --expose-gc --config ./config/.mocharc.js ./test_tmp/unit.test.js",
+        "test:node:mongodb": "npm run transpile && cross-env DEFAULT_STORAGE=mongodb mocha --expose-gc --config ./config/.mocharc.js ./test_tmp/unit.test.js",
+        "test:node:remote": "npm run transpile && cross-env DEFAULT_STORAGE=remote mocha --expose-gc --config ./config/.mocharc.js ./test_tmp/unit.test.js",
+        "test:node:lokijs:loop": "npm run test:node:lokijs && npm run test:node:lokijs:loop",
+        "test:node:memory:loop": "npm run test:node:memory && npm run test:node:memory:loop",
+        "test:node:dexie:loop": "npm run test:node:dexie && npm run test:node:dexie:loop",
+        "test:node:foundationdb:loop": "npm run test:node:foundationdb && npm run test:node:foundationdb:loop",
+        "test:node:custom": "npm run transpile && cross-env DEFAULT_STORAGE=custom mocha --expose-gc --config ./config/.mocharc.js ./test_tmp/unit.test.js",
+        "// test:node:loop": "runs tests in node in a loop. Use this to debug tests that only fail sometimes",
+        "test:node:loop": "npm run test:node && npm run test:node:loop",
+        "test:browser:loop": "npm run test:browser && npm run test:browser:loop",
+        "test:browser:lokijs": " npm run transpile && cross-env CI=true DEFAULT_STORAGE=lokijs  karma start ./config/karma.conf.js --single-run",
+        "test:browser:memory": " npm run transpile && cross-env CI=true DEFAULT_STORAGE=memory  karma start ./config/karma.conf.js --single-run",
+        "test:browser:dexie": "  npm run transpile && cross-env CI=true DEFAULT_STORAGE=dexie   karma start ./config/karma.conf.js --single-run",
+        "test:browser:remote": "  npm run transpile && cross-env CI=true DEFAULT_STORAGE=remote karma start ./config/karma.conf.js --single-run",
+        "test:browser:custom": " npm run transpile && cross-env CI=true DEFAULT_STORAGE=custom  karma start ./config/karma.conf.js --single-run",
+        "test:replication-firestore": "npm run transpile && firebase emulators:exec \"cross-env DEFAULT_STORAGE=dexie mocha --expose-gc --config ./config/.mocharc.js ./test_tmp/replication-firestore.test.js\" --only firestore --project 'rxdb-test'",
+        "test:replication-couchdb": "npm run transpile && concurrently \"npm run couch:start\" \"cross-env NATIVE_COUCHDB=5984 DEFAULT_STORAGE=dexie mocha --config ./config/.mocharc.js ./test_tmp/unit/replication-couchdb.test.js\" --success first --kill-others",
+        "test:replication-nats": "npm run transpile && concurrently \"npm run nats:start\" \"cross-env DEFAULT_STORAGE=dexie mocha --config ./config/.mocharc.js ./test_tmp/replication-nats.test.js\" --success first --kill-others",
+        "test:core": "npm run transpile && mocha ./test_tmp/unit/core.node.js",
+        "test:full": "npm run transpile && mocha ./test_tmp/unit/full.node.js",
+        "test:typings": "tsc --noEmit --lib \"ES2021,DOM\" ./test/typings.test.ts",
+        "test:deps": "npm run build && dependency-check ./package.json ./dist/lib/index.js ./dist/lib/plugins/validate-is-my-json-valid/index.js ./dist/lib/plugins/attachments-compression/index.js ./dist/lib/plugins/validate-ajv/index.js ./dist/lib/plugins/update/index.js ./dist/lib/plugins/key-compression/index.js ./dist/lib/plugins/dev-mode/index.js ./dist/lib/plugins/encryption-crypto-js/index.js ./dist/lib/plugins/replication-graphql/index.js ./dist/lib/plugins/replication-p2p/index.js ./dist/lib/plugins/replication-websocket/index.js ./dist/lib/plugins/replication-firestore/index.js ./dist/lib/plugins/replication-nats/index.js ./dist/lib/plugins/validate-z-schema/index.js ./dist/lib/plugins/storage-lokijs/index.js ./dist/lib/plugins/storage-dexie/index.js ./dist/lib/plugins/storage-memory/index.js ./dist/lib/plugins/storage-mongodb/index.js --no-dev --ignore-module util --ignore-module url --ignore-module ws --ignore-module graphql --ignore-module as-typed --ignore-module \"@types/*\"",
+        "test:circular": "npm run build && madge --circular ./dist/es/index.js && madge --circular ./dist/es/plugins/storage-dexie/index.js",
+        "test:performance:lokijs:browser": "npm run transpile && cross-env DEFAULT_STORAGE=lokijs CI=true karma start ./config/karma.performance.conf.js --single-run",
+        "test:performance:lokijs:node": "npm run transpile && cross-env DEFAULT_STORAGE=lokijs mocha --config ./config/.mocharc.js ./test_tmp/performance.test.js --unhandled-rejections=strict --expose-gc",
+        "test:performance:dexie": "npm run transpile && cross-env DEFAULT_STORAGE=dexie CI=true karma start ./config/karma.performance.conf.js --single-run",
+        "test:performance:memory:browser": "npm run transpile && cross-env DEFAULT_STORAGE=memory CI=true karma start ./config/karma.performance.conf.js --single-run",
+        "test:performance:memory:node": "npm run transpile && cross-env DEFAULT_STORAGE=memory mocha --config ./config/.mocharc.js ./test_tmp/performance.test.js --unhandled-rejections=strict --expose-gc",
+        "test:performance:memory:bun": "npm run transpile && cross-env DEFAULT_STORAGE=memory bun run ./node_modules/mocha/bin/mocha test_tmp/performance.test.js --bail",
+        "test:performance:foundationdb": "npm run transpile && cross-env DEFAULT_STORAGE=foundationdb mocha --config ./config/.mocharc.js ./test_tmp/performance.test.js --unhandled-rejections=strict --expose-gc",
+        "test:performance:mongodb": "npm run transpile && cross-env DEFAULT_STORAGE=mongodb mocha --config ./config/.mocharc.js ./test_tmp/performance.test.js --unhandled-rejections=strict --expose-gc",
+        "test:performance:custom:browser": "npm run transpile && cross-env DEFAULT_STORAGE=custom CI=true karma start ./config/karma.performance.conf.js --single-run",
+        "test:performance:custom:node": "npm run transpile && cross-env DEFAULT_STORAGE=custom mocha --config ./config/.mocharc.js ./test_tmp/performance.test.js --unhandled-rejections=strict --expose-gc",
+        "test:performance": "npm run build && npm run test:performance:lokijs:browser && npm run test:performance:lokijs:node && npm run test:performance:dexie && npm run test:performance:memory:browser && npm run test:performance:memory:node && npm run test:performance:foundationdb",
+        "couch:start": "docker run -p 5984:5984 -e COUCHDB_USER=root -e COUCHDB_PASSWORD=root --rm --name rxdb-couchdb couchdb:3.3.1",
+        "couch:stop": "docker rm -f rxdb-couchdb",
+        "mongodb:start": "docker run -p 27017:27017 -p 27018:27018 -p 27019:27019 --rm --name rxdb-mongodb mongo:7.0.1",
+        "mongodb:stop": "docker rm -f rxdb-mongodb",
+        "nats:start": "docker run --rm --name rxdb-nats -p 4222:4222 nats:2.9.17 -js",
+        "nats:stop": "docker rm -f rxdb-nats",
+        "dockertest": "docker run -it -v $(pwd):/usr/src/app markadams/chromium-xvfb-js:latest-onbuild",
+        "profile": "npm run transpile && rm -f isolate-* && cross-env STORAGE=memory NODE_ENV=fast NODE_PROF=true mocha --config ./config/.mocharc.js ./test_tmp/performance.test.js --v8-prof --expose-gc && node scripts/profile.js",
+        "clear": "rimraf -rf test_tmp/ && rimraf -rf dist/ && rimraf .transpile_state.json",
+        "lint": "eslint . --ext .js,.ts --cache",
+        "lint:fix": "eslint --fix . --ext .js,.ts",
+        "lint:debug:files": "DEBUG=eslint:cli-engine eslint --ext .js,.ts,.json .",
+        "lint:debug:time": "TIMING=1 eslint --ext .js,.ts,.json .",
+        "check-types": "tsc",
+        "transpile": "npm run build:version && node scripts/transpile.js",
+        "build:version": "node ./scripts/update-version-variable.js",
+        "build:es": "npm run build:version && rimraf -rf --max-retries=3 dist/es && cross-env NODE_ENV=es6 babel src --out-dir dist/es --source-maps --extensions \".ts,.js\"",
+        "build:types": "npm run build:version && rimraf -rf --max-retries=3 ./dist/types && tsc --project ./config/tsconfig.types.json && cp -r ./src/types ./dist/types/types",
+        "build": "npm run clear && npm run build:version && concurrently \"npm run transpile\" \"npm run build:es\" \"npm run build:types\" \"npm run build:plugins\" && browserify dist/lib/browserify.index.js > dist/rxdb.browserify.js && terser --compress --mangle --output dist/rxdb.browserify.min.js -- dist/rxdb.browserify.js",
+        "build:plugins": "node ./scripts/generate-plugins-package-json.js",
+        "build:min": "npm run transpile && browserify dist/lib/browserify.index.js > dist/rxdb.browserify.js && terser --compress --mangle --output dist/rxdb.browserify.min.js -- dist/rxdb.browserify.js",
+        "build:webpack": "npm run build && cross-env NODE_ENV=build webpack --config ./config/webpack.config.js",
+        "build:rollup": "npm run build && rollup --config ./config/rollup.config.mjs",
+        "build:size": "npm run build:webpack && echo \"Build-Size (minified+gzip):\" && gzip-size --raw ./test_tmp/webpack.bundle.js",
+        "// docs": "TODO move away from gitbook so we are not forced to use node.js version 13 to build the docs",
+        "docs:install": "gitbook install docs-src",
+        "docs:landingpage:dev": "webpack-dev-server --mode development --config ./config/landingpage.webpack.config.js",
+        "docs:landingpage:build": "npm run build && webpack --config ./config/landingpage.webpack.config.js",
+        "docs:landingpage:copy": "rm -f ./docs/index.html && cp ./docs-src/index.html ./docs/index.html",
+        "// docs:serve": "start a local server to watch the docs. Served at http://localhost:4000/",
+        "docs:serve": "gitbook serve docs-src",
+        "docs:build": "gitbook install docs-src && gitbook build docs-src docs && cp docs-src/files/logo/icon.png docs/gitbook/images/apple-touch-icon-precomposed-152.png && cp docs-src/files/logo/icon.ico docs/gitbook/images/favicon.ico && npm run docs:copy && npm run docs:remove:time",
+        "docs:copy": "cp -r docs-src/files docs/files && npm run docs:landingpage:copy",
+        "docs:remove:time": "node ./scripts/docs-remove-time.js",
+        "disc": "npm run transpile && npm run build:es && cross-env NODE_ENV=disc webpack --config ./config/webpack.config.js",
+        "preversion": "npm run lint && npm run test",
+        "dev": "watch 'npm run test:node:memory' src/ test/",
+        "dev:example": "watch 'npm run transpile:src && echo \"done\"' src/ test/"
+    },
+    "pre-commit": [
+        "lint"
+    ],
+    "peerDependencies": {
+        "rxjs": "^7.8.0"
+    },
+    "dependencies": {
+        "@babel/runtime": "7.22.15",
+        "@types/clone": "2.1.2",
+        "@types/cors": "2.8.14",
+        "@types/express": "4.17.18",
+        "@types/lokijs": "1.5.10",
+        "@types/simple-peer": "9.11.5",
+        "@types/ws": "8.5.5",
+        "ajv": "8.12.0",
+        "array-push-at-sort-position": "3.0.0",
+        "as-typed": "1.3.2",
+        "broadcast-channel": "5.3.0",
+        "custom-idle-queue": "3.0.1",
+        "dexie": "4.0.0-alpha.4",
+        "event-reduce-js": "3.1.2",
+        "get-graphql-from-jsonschema": "8.1.0",
+        "graphql": "15.8.0",
+        "graphql-ws": "5.14.0",
+        "is-my-json-valid": "2.20.6",
+        "isomorphic-ws": "5.0.0",
+        "js-base64": "3.7.5",
+        "jsonschema-key-compression": "1.6.1",
+        "lokijs": "1.5.12",
+        "mingo": "6.4.4",
+        "modifyjs": "0.3.1",
+        "mongodb": "6.1.0",
+        "nats": "2.17.0",
+        "oblivious-set": "1.1.1",
+        "ohash": "1.1.3",
+        "pako": "2.1.0",
+        "reconnecting-websocket": "4.4.0",
+        "simple-peer": "9.11.1",
+        "socket.io-client": "4.7.2",
+        "unload": "2.4.1",
+        "util": "0.12.5",
+        "ws": "8.14.2",
+        "z-schema": "6.0.1"
+    },
+    "devDependencies": {
+        "@types/node": "18.17.19",
+        "@babel/cli": "7.22.15",
+        "@babel/core": "7.22.20",
+        "@babel/plugin-external-helpers": "7.22.5",
+        "@babel/plugin-proposal-class-properties": "7.18.6",
+        "@babel/plugin-proposal-object-rest-spread": "7.20.7",
+        "@babel/plugin-transform-literals": "7.22.5",
+        "@babel/plugin-transform-member-expression-literals": "7.22.5",
+        "@babel/plugin-transform-modules-commonjs": "7.22.15",
+        "@babel/plugin-transform-property-literals": "7.22.5",
+        "@babel/plugin-transform-runtime": "7.22.15",
+        "@babel/plugin-transform-spread": "7.22.5",
+        "@babel/plugin-transform-template-literals": "7.22.5",
+        "@babel/plugin-transform-typescript": "7.22.15",
+        "@babel/polyfill": "7.12.1",
+        "@babel/preset-env": "7.22.20",
+        "@babel/preset-typescript": "7.22.15",
+        "@babel/types": "7.22.19",
+        "@faker-js/faker": "7.6.0",
+        "@rollup/plugin-commonjs": "24.1.0",
+        "@rollup/plugin-node-resolve": "15.2.1",
+        "@types/assert": "1.5.7",
+        "@types/core-js": "2.5.6",
+        "@types/cors": "2.8.14",
+        "@types/mocha": "10.0.1",
+        "@types/pako": "2.0.1",
+        "@types/request": "2.48.8",
+        "@types/request-promise-native": "1.0.18",
+        "@typescript-eslint/eslint-plugin": "5.62.0",
+        "@typescript-eslint/parser": "5.62.0",
+        "assert": "2.1.0",
+        "async-test-util": "2.1.1",
+        "babel-loader": "9.1.3",
+        "babel-plugin-transform-class-properties": "6.24.1",
+        "brfs": "2.0.2",
+        "browserify": "17.0.0",
+        "child-process-promise": "2.2.1",
+        "clone": "2.1.2",
+        "concurrently": "8.2.1",
+        "copy-webpack-plugin": "11.0.0",
+        "cors": "2.8.5",
+        "cross-env": "7.0.3",
+        "delete": "1.1.0",
+        "dependency-check": "4.1.0",
+        "detect-browser": "5.3.0",
+        "disc": "1.3.3",
+        "eslint": "8.50.0",
+        "eslint-plugin-import": "2.28.1",
+        "eslint-plugin-jsdoc": "43.2.0",
+        "exists-file": "3.0.2",
+        "express": "4.18.2",
+        "express-graphql": "0.12.0",
+        "express-pouchdb": "4.2.0",
+        "fake-indexeddb": "4.0.2",
+        "get-port": "5.1.1",
+        "gitbook-cli": "2.3.2",
+        "graphql-subscriptions": "2.0.0",
+        "gzip-size-cli": "5.1.0",
+        "html-webpack-plugin": "5.5.3",
+        "karma": "6.4.2",
+        "karma-babel-preprocessor": "8.0.2",
+        "karma-chrome-launcher": "3.2.0",
+        "karma-coverage": "2.2.1",
+        "karma-detect-browsers": "2.3.3",
+        "karma-firefox-launcher": "2.1.2",
+        "karma-ie-launcher": "1.0.0",
+        "karma-mocha": "2.0.1",
+        "karma-opera-launcher": "1.0.0",
+        "karma-safari-launcher": "1.0.0",
+        "karma-sourcemap-loader": "0.4.0",
+        "karma-spec-reporter": "0.0.36",
+        "karma-webpack": "5.0.0",
+        "leveldown": "6.1.1",
+        "madge": "6.1.0",
+        "memdown": "6.1.1",
+        "mini-css-extract-plugin": "2.7.6",
+        "mocha": "10.2.0",
+        "mocha.parallel": "0.15.6",
+        "nconf": "0.12.0",
+        "node-pre-gyp": "0.17.0",
+        "pouchdb": "8.0.1",
+        "pre-commit": "1.2.2",
+        "random-int": "3.0.0",
+        "readline": "1.3.0",
+        "rimraf": "5.0.1",
+        "rollup": "3.29.2",
+        "rxjs": "7.8.1",
+        "shelljs": "0.8.5",
+        "socket.io": "4.7.2",
+        "source-map-support": "0.5.21",
+        "stream": "0.0.2",
+        "terser": "5.20.0",
+        "terser-webpack-plugin": "5.3.9",
+        "ts-loader": "9.4.4",
+        "ts-mocha": "10.0.0",
+        "ts-node": "10.9.1",
+        "typescript": "5.2.2",
+        "walk-sync": "3.0.0",
+        "watch": "1.0.2",
+        "webpack": "5.88.2",
+        "webpack-bundle-analyzer": "4.9.1",
+        "webpack-cli": "5.1.4",
+        "webpack-dev-server": "4.15.1"
+    }
 }
\ No newline at end of file
